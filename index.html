<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Projects</title>
    <script type="module" crossorigin>(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n); new MutationObserver(n => { for (const r of n) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function s(n) { const r = {}; return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? r.credentials = "include" : n.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function i(n) { if (n.ep) return; n.ep = !0; const r = s(n); fetch(n.href, r) } })();/**
* @vue/shared v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Is(e) { const t = Object.create(null); for (const s of e.split(",")) t[s] = 1; return s => s in t } const U = {}, tt = [], ke = () => { }, Bn = () => !1, Kt = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Os = e => e.startsWith("onUpdate:"), Q = Object.assign, Ps = (e, t) => { const s = e.indexOf(t); s > -1 && e.splice(s, 1) }, Wn = Object.prototype.hasOwnProperty, F = (e, t) => Wn.call(e, t), T = Array.isArray, st = e => Gt(e) === "[object Map]", Fi = e => Gt(e) === "[object Set]", O = e => typeof e == "function", G = e => typeof e == "string", He = e => typeof e == "symbol", W = e => e !== null && typeof e == "object", zi = e => (W(e) || O(e)) && O(e.then) && O(e.catch), Di = Object.prototype.toString, Gt = e => Di.call(e), Vn = e => Gt(e).slice(8, -1), Hi = e => Gt(e) === "[object Object]", Ms = e => G(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, pt = Is(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Jt = e => { const t = Object.create(null); return s => t[s] || (t[s] = e(s)) }, Kn = /-(\w)/g, qe = Jt(e => e.replace(Kn, (t, s) => s ? s.toUpperCase() : "")), Gn = /\B([A-Z])/g, Qe = Jt(e => e.replace(Gn, "-$1").toLowerCase()), Ni = Jt(e => e.charAt(0).toUpperCase() + e.slice(1)), rs = Jt(e => e ? `on${Ni(e)}` : ""), De = (e, t) => !Object.is(e, t), os = (e, ...t) => { for (let s = 0; s < e.length; s++)e[s](...t) }, $i = (e, t, s, i = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: i, value: s }) }, Jn = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let ri; const Li = () => ri || (ri = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Rs(e) { if (T(e)) { const t = {}; for (let s = 0; s < e.length; s++) { const i = e[s], n = G(i) ? Qn(i) : Rs(i); if (n) for (const r in n) t[r] = n[r] } return t } else if (G(e) || W(e)) return e } const qn = /;(?![^(]*\))/g, Yn = /:([^]+)/, Zn = /\/\*[^]*?\*\//g; function Qn(e) { const t = {}; return e.replace(Zn, "").split(qn).forEach(s => { if (s) { const i = s.split(Yn); i.length > 1 && (t[i[0].trim()] = i[1].trim()) } }), t } function qt(e) { let t = ""; if (G(e)) t = e; else if (T(e)) for (let s = 0; s < e.length; s++) { const i = qt(e[s]); i && (t += i + " ") } else if (W(e)) for (const s in e) e[s] && (t += s + " "); return t.trim() } const Xn = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", er = Is(Xn); function Ui(e) { return !!e || e === "" } const Bi = e => !!(e && e.__v_isRef === !0), Ht = e => G(e) ? e : e == null ? "" : T(e) || W(e) && (e.toString === Di || !O(e.toString)) ? Bi(e) ? Ht(e.value) : JSON.stringify(e, Wi, 2) : String(e), Wi = (e, t) => Bi(t) ? Wi(e, t.value) : st(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((s, [i, n], r) => (s[ls(i, r) + " =>"] = n, s), {}) } : Fi(t) ? { [`Set(${t.size})`]: [...t.values()].map(s => ls(s)) } : He(t) ? ls(t) : W(t) && !T(t) && !Hi(t) ? String(t) : t, ls = (e, t = "") => { var s; return He(e) ? `Symbol(${(s = e.description) != null ? s : t})` : e };/**
* @vue/reactivity v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let fe; class tr { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = fe, !t && fe && (this.index = (fe.scopes || (fe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].pause(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].resume(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].resume() } } run(t) { if (this._active) { const s = fe; try { return fe = this, t() } finally { fe = s } } } on() { fe = this } off() { fe = this.parent } stop(t) { if (this._active) { let s, i; for (s = 0, i = this.effects.length; s < i; s++)this.effects[s].stop(); for (s = 0, i = this.cleanups.length; s < i; s++)this.cleanups[s](); if (this.scopes) for (s = 0, i = this.scopes.length; s < i; s++)this.scopes[s].stop(!0); if (!this.detached && this.parent && !t) { const n = this.parent.scopes.pop(); n && n !== this && (this.parent.scopes[this.index] = n, n.index = this.index) } this.parent = void 0, this._active = !1 } } } function sr() { return fe } let N; const cs = new WeakSet; class Vi { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.nextEffect = void 0, this.cleanup = void 0, this.scheduler = void 0, fe && fe.active && fe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, cs.has(this) && (cs.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || (this.flags |= 8, this.nextEffect = gt, gt = this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, oi(this), Gi(this); const t = N, s = ge; N = this, ge = !0; try { return this.fn() } finally { Ji(this), N = t, ge = s, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Ds(t); this.deps = this.depsTail = void 0, oi(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? cs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { _s(this) && this.run() } get dirty() { return _s(this) } } let Ki = 0, gt; function Fs() { Ki++ } function zs() { if (--Ki > 0) return; let e; for (; gt;) { let t = gt; for (gt = void 0; t;) { const s = t.nextEffect; if (t.nextEffect = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (i) { e || (e = i) } t = s } } if (e) throw e } function Gi(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Ji(e) { let t, s = e.depsTail, i = s; for (; i;) { const n = i.prevDep; i.version === -1 ? (i === s && (s = n), Ds(i), ir(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = n } e.deps = t, e.depsTail = s } function _s(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && qi(t.dep.computed) || t.dep.version !== t.version) return !0; return !!e._dirty } function qi(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === _t)) return; e.globalVersion = _t; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && !_s(e)) { e.flags &= -3; return } const s = N, i = ge; N = e, ge = !0; try { Gi(e); const n = e.fn(e._value); (t.version === 0 || De(n, e._value)) && (e._value = n, t.version++) } catch (n) { throw t.version++, n } finally { N = s, ge = i, Ji(e), e.flags &= -3 } } function Ds(e) { const { dep: t, prevSub: s, nextSub: i } = e; if (s && (s.nextSub = i, e.prevSub = void 0), i && (i.prevSub = s, e.nextSub = void 0), t.subs === e && (t.subs = s), !t.subs && t.computed) { t.computed.flags &= -5; for (let n = t.computed.deps; n; n = n.nextDep)Ds(n) } } function ir(e) { const { prevDep: t, nextDep: s } = e; t && (t.nextDep = s, e.prevDep = void 0), s && (s.prevDep = t, e.nextDep = void 0) } let ge = !0; const Yi = []; function Ne() { Yi.push(ge), ge = !1 } function $e() { const e = Yi.pop(); ge = e === void 0 ? !0 : e } function oi(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const s = N; N = void 0; try { t() } finally { N = s } } } let _t = 0; class nr { constructor(t, s) { this.sub = t, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Hs { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0 } track(t) { if (!N || !ge || N === this.computed) return; let s = this.activeLink; if (s === void 0 || s.sub !== N) s = this.activeLink = new nr(N, this), N.deps ? (s.prevDep = N.depsTail, N.depsTail.nextDep = s, N.depsTail = s) : N.deps = N.depsTail = s, N.flags & 4 && Zi(s); else if (s.version === -1 && (s.version = this.version, s.nextDep)) { const i = s.nextDep; i.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = i), s.prevDep = N.depsTail, s.nextDep = void 0, N.depsTail.nextDep = s, N.depsTail = s, N.deps === s && (N.deps = i) } return s } trigger(t) { this.version++, _t++, this.notify(t) } notify(t) { Fs(); try { for (let s = this.subs; s; s = s.prevSub)s.sub.notify() } finally { zs() } } } function Zi(e) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let i = t.deps; i; i = i.nextDep)Zi(i) } const s = e.dep.subs; s !== e && (e.prevSub = s, s && (s.nextSub = e)), e.dep.subs = e } const vs = new WeakMap, Je = Symbol(""), ws = Symbol(""), vt = Symbol(""); function X(e, t, s) { if (ge && N) { let i = vs.get(e); i || vs.set(e, i = new Map); let n = i.get(s); n || i.set(s, n = new Hs), n.track() } } function Te(e, t, s, i, n, r) { const o = vs.get(e); if (!o) { _t++; return } const c = u => { u && u.trigger() }; if (Fs(), t === "clear") o.forEach(c); else { const u = T(e), h = u && Ms(s); if (u && s === "length") { const a = Number(i); o.forEach((p, w) => { (w === "length" || w === vt || !He(w) && w >= a) && c(p) }) } else switch (s !== void 0 && c(o.get(s)), h && c(o.get(vt)), t) { case "add": u ? h && c(o.get("length")) : (c(o.get(Je)), st(e) && c(o.get(ws))); break; case "delete": u || (c(o.get(Je)), st(e) && c(o.get(ws))); break; case "set": st(e) && c(o.get(Je)); break } } zs() } function Xe(e) { const t = z(e); return t === e ? t : (X(t, "iterate", vt), he(e) ? t : t.map(Y)) } function Yt(e) { return X(e = z(e), "iterate", vt), e } const rr = { __proto__: null, [Symbol.iterator]() { return fs(this, Symbol.iterator, Y) }, concat(...e) { return Xe(this).concat(...e.map(t => T(t) ? Xe(t) : t)) }, entries() { return fs(this, "entries", e => (e[1] = Y(e[1]), e)) }, every(e, t) { return Se(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Se(this, "filter", e, t, s => s.map(Y), arguments) }, find(e, t) { return Se(this, "find", e, t, Y, arguments) }, findIndex(e, t) { return Se(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Se(this, "findLast", e, t, Y, arguments) }, findLastIndex(e, t) { return Se(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Se(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return us(this, "includes", e) }, indexOf(...e) { return us(this, "indexOf", e) }, join(e) { return Xe(this).join(e) }, lastIndexOf(...e) { return us(this, "lastIndexOf", e) }, map(e, t) { return Se(this, "map", e, t, void 0, arguments) }, pop() { return at(this, "pop") }, push(...e) { return at(this, "push", e) }, reduce(e, ...t) { return li(this, "reduce", e, t) }, reduceRight(e, ...t) { return li(this, "reduceRight", e, t) }, shift() { return at(this, "shift") }, some(e, t) { return Se(this, "some", e, t, void 0, arguments) }, splice(...e) { return at(this, "splice", e) }, toReversed() { return Xe(this).toReversed() }, toSorted(e) { return Xe(this).toSorted(e) }, toSpliced(...e) { return Xe(this).toSpliced(...e) }, unshift(...e) { return at(this, "unshift", e) }, values() { return fs(this, "values", Y) } }; function fs(e, t, s) { const i = Yt(e), n = i[t](); return i !== e && !he(e) && (n._next = n.next, n.next = () => { const r = n._next(); return r.value && (r.value = s(r.value)), r }), n } const or = Array.prototype; function Se(e, t, s, i, n, r) { const o = Yt(e), c = o !== e && !he(e), u = o[t]; if (u !== or[t]) { const p = u.apply(e, r); return c ? Y(p) : p } let h = s; o !== e && (c ? h = function (p, w) { return s.call(this, Y(p), w, e) } : s.length > 2 && (h = function (p, w) { return s.call(this, p, w, e) })); const a = u.call(o, h, i); return c && n ? n(a) : a } function li(e, t, s, i) { const n = Yt(e); let r = s; return n !== e && (he(e) ? s.length > 3 && (r = function (o, c, u) { return s.call(this, o, c, u, e) }) : r = function (o, c, u) { return s.call(this, o, Y(c), u, e) }), n[t](r, ...i) } function us(e, t, s) { const i = z(e); X(i, "iterate", vt); const n = i[t](...s); return (n === -1 || n === !1) && Bs(s[0]) ? (s[0] = z(s[0]), i[t](...s)) : n } function at(e, t, s = []) { Ne(), Fs(); const i = z(e)[t].apply(e, s); return zs(), $e(), i } const lr = Is("__proto__,__v_isRef,__isVue"), Qi = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(He)); function cr(e) { He(e) || (e = String(e)); const t = z(this); return X(t, "has", e), t.hasOwnProperty(e) } class Xi { constructor(t = !1, s = !1) { this._isReadonly = t, this._isShallow = s } get(t, s, i) { const n = this._isReadonly, r = this._isShallow; if (s === "__v_isReactive") return !n; if (s === "__v_isReadonly") return n; if (s === "__v_isShallow") return r; if (s === "__v_raw") return i === (n ? r ? wr : nn : r ? sn : tn).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0; const o = T(t); if (!n) { let u; if (o && (u = rr[s])) return u; if (s === "hasOwnProperty") return cr } const c = Reflect.get(t, s, Z(t) ? t : i); return (He(s) ? Qi.has(s) : lr(s)) || (n || X(t, "get", s), r) ? c : Z(c) ? o && Ms(s) ? c : c.value : W(c) ? n ? rn(c) : Ls(c) : c } } class en extends Xi { constructor(t = !1) { super(!1, t) } set(t, s, i, n) { let r = t[s]; if (!this._isShallow) { const u = Ye(r); if (!he(i) && !Ye(i) && (r = z(r), i = z(i)), !T(t) && Z(r) && !Z(i)) return u ? !1 : (r.value = i, !0) } const o = T(t) && Ms(s) ? Number(s) < t.length : F(t, s), c = Reflect.set(t, s, i, Z(t) ? t : n); return t === z(n) && (o ? De(i, r) && Te(t, "set", s, i) : Te(t, "add", s, i)), c } deleteProperty(t, s) { const i = F(t, s); t[s]; const n = Reflect.deleteProperty(t, s); return n && i && Te(t, "delete", s, void 0), n } has(t, s) { const i = Reflect.has(t, s); return (!He(s) || !Qi.has(s)) && X(t, "has", s), i } ownKeys(t) { return X(t, "iterate", T(t) ? "length" : Je), Reflect.ownKeys(t) } } class fr extends Xi { constructor(t = !1) { super(!0, t) } set(t, s) { return !0 } deleteProperty(t, s) { return !0 } } const ur = new en, ar = new fr, dr = new en(!0); const Ns = e => e, Zt = e => Reflect.getPrototypeOf(e); function Ot(e, t, s = !1, i = !1) { e = e.__v_raw; const n = z(e), r = z(t); s || (De(t, r) && X(n, "get", t), X(n, "get", r)); const { has: o } = Zt(n), c = i ? Ns : s ? Ws : Y; if (o.call(n, t)) return c(e.get(t)); if (o.call(n, r)) return c(e.get(r)); e !== n && e.get(t) } function Pt(e, t = !1) { const s = this.__v_raw, i = z(s), n = z(e); return t || (De(e, n) && X(i, "has", e), X(i, "has", n)), e === n ? s.has(e) : s.has(e) || s.has(n) } function Mt(e, t = !1) { return e = e.__v_raw, !t && X(z(e), "iterate", Je), Reflect.get(e, "size", e) } function ci(e, t = !1) { !t && !he(e) && !Ye(e) && (e = z(e)); const s = z(this); return Zt(s).has.call(s, e) || (s.add(e), Te(s, "add", e, e)), this } function fi(e, t, s = !1) { !s && !he(t) && !Ye(t) && (t = z(t)); const i = z(this), { has: n, get: r } = Zt(i); let o = n.call(i, e); o || (e = z(e), o = n.call(i, e)); const c = r.call(i, e); return i.set(e, t), o ? De(t, c) && Te(i, "set", e, t) : Te(i, "add", e, t), this } function ui(e) { const t = z(this), { has: s, get: i } = Zt(t); let n = s.call(t, e); n || (e = z(e), n = s.call(t, e)), i && i.call(t, e); const r = t.delete(e); return n && Te(t, "delete", e, void 0), r } function ai() { const e = z(this), t = e.size !== 0, s = e.clear(); return t && Te(e, "clear", void 0, void 0), s } function Rt(e, t) { return function (i, n) { const r = this, o = r.__v_raw, c = z(o), u = t ? Ns : e ? Ws : Y; return !e && X(c, "iterate", Je), o.forEach((h, a) => i.call(n, u(h), u(a), r)) } } function Ft(e, t, s) { return function (...i) { const n = this.__v_raw, r = z(n), o = st(r), c = e === "entries" || e === Symbol.iterator && o, u = e === "keys" && o, h = n[e](...i), a = s ? Ns : t ? Ws : Y; return !t && X(r, "iterate", u ? ws : Je), { next() { const { value: p, done: w } = h.next(); return w ? { value: p, done: w } : { value: c ? [a(p[0]), a(p[1])] : a(p), done: w } }, [Symbol.iterator]() { return this } } } } function Pe(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function hr() { const e = { get(r) { return Ot(this, r) }, get size() { return Mt(this) }, has: Pt, add: ci, set: fi, delete: ui, clear: ai, forEach: Rt(!1, !1) }, t = { get(r) { return Ot(this, r, !1, !0) }, get size() { return Mt(this) }, has: Pt, add(r) { return ci.call(this, r, !0) }, set(r, o) { return fi.call(this, r, o, !0) }, delete: ui, clear: ai, forEach: Rt(!1, !0) }, s = { get(r) { return Ot(this, r, !0) }, get size() { return Mt(this, !0) }, has(r) { return Pt.call(this, r, !0) }, add: Pe("add"), set: Pe("set"), delete: Pe("delete"), clear: Pe("clear"), forEach: Rt(!0, !1) }, i = { get(r) { return Ot(this, r, !0, !0) }, get size() { return Mt(this, !0) }, has(r) { return Pt.call(this, r, !0) }, add: Pe("add"), set: Pe("set"), delete: Pe("delete"), clear: Pe("clear"), forEach: Rt(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(r => { e[r] = Ft(r, !1, !1), s[r] = Ft(r, !0, !1), t[r] = Ft(r, !1, !0), i[r] = Ft(r, !0, !0) }), [e, s, t, i] } const [pr, gr, mr, br] = hr(); function $s(e, t) { const s = t ? e ? br : mr : e ? gr : pr; return (i, n, r) => n === "__v_isReactive" ? !e : n === "__v_isReadonly" ? e : n === "__v_raw" ? i : Reflect.get(F(s, n) && n in i ? s : i, n, r) } const yr = { get: $s(!1, !1) }, _r = { get: $s(!1, !0) }, vr = { get: $s(!0, !1) }; const tn = new WeakMap, sn = new WeakMap, nn = new WeakMap, wr = new WeakMap; function xr(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function kr(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : xr(Vn(e)) } function Ls(e) { return Ye(e) ? e : Us(e, !1, ur, yr, tn) } function jr(e) { return Us(e, !1, dr, _r, sn) } function rn(e) { return Us(e, !0, ar, vr, nn) } function Us(e, t, s, i, n) { if (!W(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const r = n.get(e); if (r) return r; const o = kr(e); if (o === 0) return e; const c = new Proxy(e, o === 2 ? i : s); return n.set(e, c), c } function it(e) { return Ye(e) ? it(e.__v_raw) : !!(e && e.__v_isReactive) } function Ye(e) { return !!(e && e.__v_isReadonly) } function he(e) { return !!(e && e.__v_isShallow) } function Bs(e) { return e ? !!e.__v_raw : !1 } function z(e) { const t = e && e.__v_raw; return t ? z(t) : e } function Sr(e) { return !F(e, "__v_skip") && Object.isExtensible(e) && $i(e, "__v_skip", !0), e } const Y = e => W(e) ? Ls(e) : e, Ws = e => W(e) ? rn(e) : e; function Z(e) { return e ? e.__v_isRef === !0 : !1 } function as(e) { return Cr(e, !1) } function Cr(e, t) { return Z(e) ? e : new Ar(e, t) } class Ar { constructor(t, s) { this.dep = new Hs, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? t : z(t), this._value = s ? t : Y(t), this.__v_isShallow = s } get value() { return this.dep.track(), this._value } set value(t) { const s = this._rawValue, i = this.__v_isShallow || he(t) || Ye(t); t = i ? t : z(t), De(t, s) && (this._rawValue = t, this._value = i ? t : Y(t), this.dep.trigger()) } } function on(e) { return Z(e) ? e.value : e } const Tr = { get: (e, t, s) => t === "__v_raw" ? e : on(Reflect.get(e, t, s)), set: (e, t, s, i) => { const n = e[t]; return Z(n) && !Z(s) ? (n.value = s, !0) : Reflect.set(e, t, s, i) } }; function ln(e) { return it(e) ? e : new Proxy(e, Tr) } class Er { constructor(t, s, i) { this.fn = t, this.setter = s, this._value = void 0, this.dep = new Hs(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = _t - 1, this.effect = this, this.__v_isReadonly = !s, this.isSSR = i } notify() { this.flags |= 16, N !== this && this.dep.notify() } get value() { const t = this.dep.track(); return qi(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function Ir(e, t, s = !1) { let i, n; return O(e) ? i = e : (i = e.get, n = e.set), new Er(i, n, s) } const zt = {}, Ut = new WeakMap; let Ke; function Or(e, t = !1, s = Ke) { if (s) { let i = Ut.get(s); i || Ut.set(s, i = []), i.push(e) } } function Pr(e, t, s = U) { const { immediate: i, deep: n, once: r, scheduler: o, augmentJob: c, call: u } = s, h = C => n ? C : he(C) || n === !1 || n === 0 ? Fe(C, 1) : Fe(C); let a, p, w, E, R = !1, M = !1; if (Z(e) ? (p = () => e.value, R = he(e)) : it(e) ? (p = () => h(e), R = !0) : T(e) ? (M = !0, R = e.some(C => it(C) || he(C)), p = () => e.map(C => { if (Z(C)) return C.value; if (it(C)) return h(C); if (O(C)) return u ? u(C, 2) : C() })) : O(e) ? t ? p = u ? () => u(e, 2) : e : p = () => { if (w) { Ne(); try { w() } finally { $e() } } const C = Ke; Ke = a; try { return u ? u(e, 3, [E]) : e(E) } finally { Ke = C } } : p = ke, t && n) { const C = p, J = n === !0 ? 1 / 0 : n; p = () => Fe(C(), J) } const ee = sr(), H = () => { a.stop(), ee && Ps(ee.effects, a) }; if (r) if (t) { const C = t; t = (...J) => { C(...J), H() } } else { const C = p; p = () => { C(), H() } } let V = M ? new Array(e.length).fill(zt) : zt; const K = C => { if (!(!(a.flags & 1) || !a.dirty && !C)) if (t) { const J = a.run(); if (n || R || (M ? J.some((Ie, me) => De(Ie, V[me])) : De(J, V))) { w && w(); const Ie = Ke; Ke = a; try { const me = [J, V === zt ? void 0 : M && V[0] === zt ? [] : V, E]; u ? u(t, 3, me) : t(...me), V = J } finally { Ke = Ie } } } else a.run() }; return c && c(K), a = new Vi(p), a.scheduler = o ? () => o(K, !1) : K, E = C => Or(C, !1, a), w = a.onStop = () => { const C = Ut.get(a); if (C) { if (u) u(C, 4); else for (const J of C) J(); Ut.delete(a) } }, t ? i ? K(!0) : V = a.run() : o ? o(K.bind(null, !0), !0) : a.run(), H.pause = a.pause.bind(a), H.resume = a.resume.bind(a), H.stop = H, H } function Fe(e, t = 1 / 0, s) { if (t <= 0 || !W(e) || e.__v_skip || (s = s || new Set, s.has(e))) return e; if (s.add(e), t--, Z(e)) Fe(e.value, t, s); else if (T(e)) for (let i = 0; i < e.length; i++)Fe(e[i], t, s); else if (Fi(e) || st(e)) e.forEach(i => { Fe(i, t, s) }); else if (Hi(e)) { for (const i in e) Fe(e[i], t, s); for (const i of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, i) && Fe(e[i], t, s) } return e }/**
* @vue/runtime-core v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function jt(e, t, s, i) { try { return i ? e(...i) : e() } catch (n) { Qt(n, t, s) } } function je(e, t, s, i) { if (O(e)) { const n = jt(e, t, s, i); return n && zi(n) && n.catch(r => { Qt(r, t, s) }), n } if (T(e)) { const n = []; for (let r = 0; r < e.length; r++)n.push(je(e[r], t, s, i)); return n } } function Qt(e, t, s, i = !0) { const n = t ? t.vnode : null, { errorHandler: r, throwUnhandledErrorInProduction: o } = t && t.appContext.config || U; if (t) { let c = t.parent; const u = t.proxy, h = `https://vuejs.org/error-reference/#runtime-${s}`; for (; c;) { const a = c.ec; if (a) { for (let p = 0; p < a.length; p++)if (a[p](e, u, h) === !1) return } c = c.parent } if (r) { Ne(), jt(r, null, 10, [e, u, h]), $e(); return } } Mr(e, s, n, i, o) } function Mr(e, t, s, i = !0, n = !1) { if (n) throw e; console.error(e) } let wt = !1, xs = !1; const ie = []; let ve = 0; const nt = []; let Me = null, et = 0; const cn = Promise.resolve(); let Vs = null; function Rr(e) { const t = Vs || cn; return e ? t.then(this ? e.bind(this) : e) : t } function Fr(e) { let t = wt ? ve + 1 : 0, s = ie.length; for (; t < s;) { const i = t + s >>> 1, n = ie[i], r = xt(n); r < e || r === e && n.flags & 2 ? t = i + 1 : s = i } return t } function Ks(e) { if (!(e.flags & 1)) { const t = xt(e), s = ie[ie.length - 1]; !s || !(e.flags & 2) && t >= xt(s) ? ie.push(e) : ie.splice(Fr(t), 0, e), e.flags |= 1, fn() } } function fn() { !wt && !xs && (xs = !0, Vs = cn.then(an)) } function zr(e) { T(e) ? nt.push(...e) : Me && e.id === -1 ? Me.splice(et + 1, 0, e) : e.flags & 1 || (nt.push(e), e.flags |= 1), fn() } function di(e, t, s = wt ? ve + 1 : 0) { for (; s < ie.length; s++) { const i = ie[s]; if (i && i.flags & 2) { if (e && i.id !== e.uid) continue; ie.splice(s, 1), s--, i.flags & 4 && (i.flags &= -2), i(), i.flags &= -2 } } } function un(e) { if (nt.length) { const t = [...new Set(nt)].sort((s, i) => xt(s) - xt(i)); if (nt.length = 0, Me) { Me.push(...t); return } for (Me = t, et = 0; et < Me.length; et++) { const s = Me[et]; s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2 } Me = null, et = 0 } } const xt = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function an(e) { xs = !1, wt = !0; try { for (ve = 0; ve < ie.length; ve++) { const t = ie[ve]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), jt(t, t.i, t.i ? 15 : 14), t.flags &= -2) } } finally { for (; ve < ie.length; ve++) { const t = ie[ve]; t && (t.flags &= -2) } ve = 0, ie.length = 0, un(), wt = !1, Vs = null, (ie.length || nt.length) && an() } } let xe = null, dn = null; function Bt(e) { const t = xe; return xe = e, dn = e && e.type.__scopeId || null, t } function Dr(e, t = xe, s) { if (!t || e._n) return e; const i = (...n) => { i._d && vi(-1); const r = Bt(t); let o; try { o = e(...n) } finally { Bt(r), i._d && vi(1) } return o }; return i._n = !0, i._c = !0, i._d = !0, i } function We(e, t, s, i) { const n = e.dirs, r = t && t.dirs; for (let o = 0; o < n.length; o++) { const c = n[o]; r && (c.oldValue = r[o].value); let u = c.dir[i]; u && (Ne(), je(u, s, 8, [e.el, c, e, t]), $e()) } } const Hr = Symbol("_vte"), Nr = e => e.__isTeleport; function Gs(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Gs(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function hn(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function ks(e, t, s, i, n = !1) { if (T(e)) { e.forEach((R, M) => ks(R, t && (T(t) ? t[M] : t), s, i, n)); return } if (mt(i) && !n) return; const r = i.shapeFlag & 4 ? Zs(i.component) : i.el, o = n ? null : r, { i: c, r: u } = e, h = t && t.r, a = c.refs === U ? c.refs = {} : c.refs, p = c.setupState, w = z(p), E = p === U ? () => !1 : R => F(w, R); if (h != null && h !== u && (G(h) ? (a[h] = null, E(h) && (p[h] = null)) : Z(h) && (h.value = null)), O(u)) jt(u, c, 12, [o, a]); else { const R = G(u), M = Z(u); if (R || M) { const ee = () => { if (e.f) { const H = R ? E(u) ? p[u] : a[u] : u.value; n ? T(H) && Ps(H, r) : T(H) ? H.includes(r) || H.push(r) : R ? (a[u] = [r], E(u) && (p[u] = a[u])) : (u.value = [r], e.k && (a[e.k] = u.value)) } else R ? (a[u] = o, E(u) && (p[u] = o)) : M && (u.value = o, e.k && (a[e.k] = o)) }; o ? (ee.id = -1, ce(ee, s)) : ee() } } } const mt = e => !!e.type.__asyncLoader, pn = e => e.type.__isKeepAlive; function $r(e, t) { gn(e, "a", t) } function Lr(e, t) { gn(e, "da", t) } function gn(e, t, s = ne) { const i = e.__wdc || (e.__wdc = () => { let n = s; for (; n;) { if (n.isDeactivated) return; n = n.parent } return e() }); if (Xt(t, i, s), s) { let n = s.parent; for (; n && n.parent;)pn(n.parent.vnode) && Ur(i, t, s, n), n = n.parent } } function Ur(e, t, s, i) { const n = Xt(t, e, i, !0); mn(() => { Ps(i[t], n) }, s) } function Xt(e, t, s = ne, i = !1) { if (s) { const n = s[e] || (s[e] = []), r = t.__weh || (t.__weh = (...o) => { Ne(); const c = St(s), u = je(t, s, e, o); return c(), $e(), u }); return i ? n.unshift(r) : n.push(r), r } } const Ee = e => (t, s = ne) => { (!ss || e === "sp") && Xt(e, (...i) => t(...i), s) }, Br = Ee("bm"), Wr = Ee("m"), Vr = Ee("bu"), Kr = Ee("u"), Gr = Ee("bum"), mn = Ee("um"), Jr = Ee("sp"), qr = Ee("rtg"), Yr = Ee("rtc"); function Zr(e, t = ne) { Xt("ec", e, t) } const Qr = Symbol.for("v-ndc"); function bn(e, t, s, i) { let n; const r = s, o = T(e); if (o || G(e)) { const c = o && it(e); let u = !1; c && (u = !he(e), e = Yt(e)), n = new Array(e.length); for (let h = 0, a = e.length; h < a; h++)n[h] = t(u ? Y(e[h]) : e[h], h, void 0, r) } else if (typeof e == "number") { n = new Array(e); for (let c = 0; c < e; c++)n[c] = t(c + 1, c, void 0, r) } else if (W(e)) if (e[Symbol.iterator]) n = Array.from(e, (c, u) => t(c, u, void 0, r)); else { const c = Object.keys(e); n = new Array(c.length); for (let u = 0, h = c.length; u < h; u++) { const a = c[u]; n[u] = t(e[a], a, u, r) } } else n = []; return n } const js = e => e ? Hn(e) ? Zs(e) : js(e.parent) : null, bt = Q(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => js(e.parent), $root: e => js(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => Js(e), $forceUpdate: e => e.f || (e.f = () => { Ks(e.update) }), $nextTick: e => e.n || (e.n = Rr.bind(e.proxy)), $watch: e => wo.bind(e) }), ds = (e, t) => e !== U && !e.__isScriptSetup && F(e, t), Xr = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: s, setupState: i, data: n, props: r, accessCache: o, type: c, appContext: u } = e; let h; if (t[0] !== "$") { const E = o[t]; if (E !== void 0) switch (E) { case 1: return i[t]; case 2: return n[t]; case 4: return s[t]; case 3: return r[t] } else { if (ds(i, t)) return o[t] = 1, i[t]; if (n !== U && F(n, t)) return o[t] = 2, n[t]; if ((h = e.propsOptions[0]) && F(h, t)) return o[t] = 3, r[t]; if (s !== U && F(s, t)) return o[t] = 4, s[t]; Ss && (o[t] = 0) } } const a = bt[t]; let p, w; if (a) return t === "$attrs" && X(e.attrs, "get", ""), a(e); if ((p = c.__cssModules) && (p = p[t])) return p; if (s !== U && F(s, t)) return o[t] = 4, s[t]; if (w = u.config.globalProperties, F(w, t)) return w[t] }, set({ _: e }, t, s) { const { data: i, setupState: n, ctx: r } = e; return ds(n, t) ? (n[t] = s, !0) : i !== U && F(i, t) ? (i[t] = s, !0) : F(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = s, !0) }, has({ _: { data: e, setupState: t, accessCache: s, ctx: i, appContext: n, propsOptions: r } }, o) { let c; return !!s[o] || e !== U && F(e, o) || ds(t, o) || (c = r[0]) && F(c, o) || F(i, o) || F(bt, o) || F(n.config.globalProperties, o) }, defineProperty(e, t, s) { return s.get != null ? e._.accessCache[t] = 0 : F(s, "value") && this.set(e, t, s.value, null), Reflect.defineProperty(e, t, s) } }; function hi(e) { return T(e) ? e.reduce((t, s) => (t[s] = null, t), {}) : e } let Ss = !0; function eo(e) { const t = Js(e), s = e.proxy, i = e.ctx; Ss = !1, t.beforeCreate && pi(t.beforeCreate, e, "bc"); const { data: n, computed: r, methods: o, watch: c, provide: u, inject: h, created: a, beforeMount: p, mounted: w, beforeUpdate: E, updated: R, activated: M, deactivated: ee, beforeDestroy: H, beforeUnmount: V, destroyed: K, unmounted: C, render: J, renderTracked: Ie, renderTriggered: me, errorCaptured: Oe, serverPrefetch: Ct, expose: Le, inheritAttrs: lt, components: At, directives: Tt, filters: is } = t; if (h && to(h, i, null), o) for (const B in o) { const $ = o[B]; O($) && (i[B] = $.bind(s)) } if (n) { const B = n.call(s, s); W(B) && (e.data = Ls(B)) } if (Ss = !0, r) for (const B in r) { const $ = r[B], Ue = O($) ? $.bind(s, s) : O($.get) ? $.get.bind(s, s) : ke, Et = !O($) && O($.set) ? $.set.bind(s) : ke, Be = Bo({ get: Ue, set: Et }); Object.defineProperty(i, B, { enumerable: !0, configurable: !0, get: () => Be.value, set: be => Be.value = be }) } if (c) for (const B in c) yn(c[B], i, s, B); if (u) { const B = O(u) ? u.call(s) : u; Reflect.ownKeys(B).forEach($ => { lo($, B[$]) }) } a && pi(a, e, "c"); function te(B, $) { T($) ? $.forEach(Ue => B(Ue.bind(s))) : $ && B($.bind(s)) } if (te(Br, p), te(Wr, w), te(Vr, E), te(Kr, R), te($r, M), te(Lr, ee), te(Zr, Oe), te(Yr, Ie), te(qr, me), te(Gr, V), te(mn, C), te(Jr, Ct), T(Le)) if (Le.length) { const B = e.exposed || (e.exposed = {}); Le.forEach($ => { Object.defineProperty(B, $, { get: () => s[$], set: Ue => s[$] = Ue }) }) } else e.exposed || (e.exposed = {}); J && e.render === ke && (e.render = J), lt != null && (e.inheritAttrs = lt), At && (e.components = At), Tt && (e.directives = Tt), Ct && hn(e) } function to(e, t, s = ke) { T(e) && (e = Cs(e)); for (const i in e) { const n = e[i]; let r; W(n) ? "default" in n ? r = Nt(n.from || i, n.default, !0) : r = Nt(n.from || i) : r = Nt(n), Z(r) ? Object.defineProperty(t, i, { enumerable: !0, configurable: !0, get: () => r.value, set: o => r.value = o }) : t[i] = r } } function pi(e, t, s) { je(T(e) ? e.map(i => i.bind(t.proxy)) : e.bind(t.proxy), t, s) } function yn(e, t, s, i) { let n = i.includes(".") ? Pn(s, i) : () => s[i]; if (G(e)) { const r = t[e]; O(r) && ps(n, r) } else if (O(e)) ps(n, e.bind(s)); else if (W(e)) if (T(e)) e.forEach(r => yn(r, t, s, i)); else { const r = O(e.handler) ? e.handler.bind(s) : t[e.handler]; O(r) && ps(n, r, e) } } function Js(e) { const t = e.type, { mixins: s, extends: i } = t, { mixins: n, optionsCache: r, config: { optionMergeStrategies: o } } = e.appContext, c = r.get(t); let u; return c ? u = c : !n.length && !s && !i ? u = t : (u = {}, n.length && n.forEach(h => Wt(u, h, o, !0)), Wt(u, t, o)), W(t) && r.set(t, u), u } function Wt(e, t, s, i = !1) { const { mixins: n, extends: r } = t; r && Wt(e, r, s, !0), n && n.forEach(o => Wt(e, o, s, !0)); for (const o in t) if (!(i && o === "expose")) { const c = so[o] || s && s[o]; e[o] = c ? c(e[o], t[o]) : t[o] } return e } const so = { data: gi, props: mi, emits: mi, methods: ht, computed: ht, beforeCreate: se, created: se, beforeMount: se, mounted: se, beforeUpdate: se, updated: se, beforeDestroy: se, beforeUnmount: se, destroyed: se, unmounted: se, activated: se, deactivated: se, errorCaptured: se, serverPrefetch: se, components: ht, directives: ht, watch: no, provide: gi, inject: io }; function gi(e, t) { return t ? e ? function () { return Q(O(e) ? e.call(this, this) : e, O(t) ? t.call(this, this) : t) } : t : e } function io(e, t) { return ht(Cs(e), Cs(t)) } function Cs(e) { if (T(e)) { const t = {}; for (let s = 0; s < e.length; s++)t[e[s]] = e[s]; return t } return e } function se(e, t) { return e ? [...new Set([].concat(e, t))] : t } function ht(e, t) { return e ? Q(Object.create(null), e, t) : t } function mi(e, t) { return e ? T(e) && T(t) ? [...new Set([...e, ...t])] : Q(Object.create(null), hi(e), hi(t ?? {})) : t } function no(e, t) { if (!e) return t; if (!t) return e; const s = Q(Object.create(null), e); for (const i in t) s[i] = se(e[i], t[i]); return s } function _n() { return { app: null, config: { isNativeTag: Bn, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let ro = 0; function oo(e, t) { return function (i, n = null) { O(i) || (i = Q({}, i)), n != null && !W(n) && (n = null); const r = _n(), o = new WeakSet, c = []; let u = !1; const h = r.app = { _uid: ro++, _component: i, _props: n, _container: null, _context: r, _instance: null, version: Wo, get config() { return r.config }, set config(a) { }, use(a, ...p) { return o.has(a) || (a && O(a.install) ? (o.add(a), a.install(h, ...p)) : O(a) && (o.add(a), a(h, ...p))), h }, mixin(a) { return r.mixins.includes(a) || r.mixins.push(a), h }, component(a, p) { return p ? (r.components[a] = p, h) : r.components[a] }, directive(a, p) { return p ? (r.directives[a] = p, h) : r.directives[a] }, mount(a, p, w) { if (!u) { const E = h._ceVNode || ae(i, n); return E.appContext = r, w === !0 ? w = "svg" : w === !1 && (w = void 0), p && t ? t(E, a) : e(E, a, w), u = !0, h._container = a, a.__vue_app__ = h, Zs(E.component) } }, onUnmount(a) { c.push(a) }, unmount() { u && (je(c, h._instance, 16), e(null, h._container), delete h._container.__vue_app__) }, provide(a, p) { return r.provides[a] = p, h }, runWithContext(a) { const p = rt; rt = h; try { return a() } finally { rt = p } } }; return h } } let rt = null; function lo(e, t) { if (ne) { let s = ne.provides; const i = ne.parent && ne.parent.provides; i === s && (s = ne.provides = Object.create(i)), s[e] = t } } function Nt(e, t, s = !1) { const i = ne || xe; if (i || rt) { const n = rt ? rt._context.provides : i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0; if (n && e in n) return n[e]; if (arguments.length > 1) return s && O(t) ? t.call(i && i.proxy) : t } } const vn = {}, wn = () => Object.create(vn), xn = e => Object.getPrototypeOf(e) === vn; function co(e, t, s, i = !1) { const n = {}, r = wn(); e.propsDefaults = Object.create(null), kn(e, t, n, r); for (const o in e.propsOptions[0]) o in n || (n[o] = void 0); s ? e.props = i ? n : jr(n) : e.type.props ? e.props = n : e.props = r, e.attrs = r } function fo(e, t, s, i) { const { props: n, attrs: r, vnode: { patchFlag: o } } = e, c = z(n), [u] = e.propsOptions; let h = !1; if ((i || o > 0) && !(o & 16)) { if (o & 8) { const a = e.vnode.dynamicProps; for (let p = 0; p < a.length; p++) { let w = a[p]; if (es(e.emitsOptions, w)) continue; const E = t[w]; if (u) if (F(r, w)) E !== r[w] && (r[w] = E, h = !0); else { const R = qe(w); n[R] = As(u, c, R, E, e, !1) } else E !== r[w] && (r[w] = E, h = !0) } } } else { kn(e, t, n, r) && (h = !0); let a; for (const p in c) (!t || !F(t, p) && ((a = Qe(p)) === p || !F(t, a))) && (u ? s && (s[p] !== void 0 || s[a] !== void 0) && (n[p] = As(u, c, p, void 0, e, !0)) : delete n[p]); if (r !== c) for (const p in r) (!t || !F(t, p)) && (delete r[p], h = !0) } h && Te(e.attrs, "set", "") } function kn(e, t, s, i) { const [n, r] = e.propsOptions; let o = !1, c; if (t) for (let u in t) { if (pt(u)) continue; const h = t[u]; let a; n && F(n, a = qe(u)) ? !r || !r.includes(a) ? s[a] = h : (c || (c = {}))[a] = h : es(e.emitsOptions, u) || (!(u in i) || h !== i[u]) && (i[u] = h, o = !0) } if (r) { const u = z(s), h = c || U; for (let a = 0; a < r.length; a++) { const p = r[a]; s[p] = As(n, u, p, h[p], e, !F(h, p)) } } return o } function As(e, t, s, i, n, r) { const o = e[s]; if (o != null) { const c = F(o, "default"); if (c && i === void 0) { const u = o.default; if (o.type !== Function && !o.skipFactory && O(u)) { const { propsDefaults: h } = n; if (s in h) i = h[s]; else { const a = St(n); i = h[s] = u.call(null, t), a() } } else i = u; n.ce && n.ce._setProp(s, i) } o[0] && (r && !c ? i = !1 : o[1] && (i === "" || i === Qe(s)) && (i = !0)) } return i } const uo = new WeakMap; function jn(e, t, s = !1) { const i = s ? uo : t.propsCache, n = i.get(e); if (n) return n; const r = e.props, o = {}, c = []; let u = !1; if (!O(e)) { const a = p => { u = !0; const [w, E] = jn(p, t, !0); Q(o, w), E && c.push(...E) }; !s && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!r && !u) return W(e) && i.set(e, tt), tt; if (T(r)) for (let a = 0; a < r.length; a++) { const p = qe(r[a]); bi(p) && (o[p] = U) } else if (r) for (const a in r) { const p = qe(a); if (bi(p)) { const w = r[a], E = o[p] = T(w) || O(w) ? { type: w } : Q({}, w), R = E.type; let M = !1, ee = !0; if (T(R)) for (let H = 0; H < R.length; ++H) { const V = R[H], K = O(V) && V.name; if (K === "Boolean") { M = !0; break } else K === "String" && (ee = !1) } else M = O(R) && R.name === "Boolean"; E[0] = M, E[1] = ee, (M || F(E, "default")) && c.push(p) } } const h = [o, c]; return W(e) && i.set(e, h), h } function bi(e) { return e[0] !== "$" && !pt(e) } const Sn = e => e[0] === "_" || e === "$stable", qs = e => T(e) ? e.map(we) : [we(e)], ao = (e, t, s) => { if (t._n) return t; const i = Dr((...n) => qs(t(...n)), s); return i._c = !1, i }, Cn = (e, t, s) => { const i = e._ctx; for (const n in e) { if (Sn(n)) continue; const r = e[n]; if (O(r)) t[n] = ao(n, r, i); else if (r != null) { const o = qs(r); t[n] = () => o } } }, An = (e, t) => { const s = qs(t); e.slots.default = () => s }, Tn = (e, t, s) => { for (const i in t) (s || i !== "_") && (e[i] = t[i]) }, ho = (e, t, s) => { const i = e.slots = wn(); if (e.vnode.shapeFlag & 32) { const n = t._; n ? (Tn(i, t, s), s && $i(i, "_", n, !0)) : Cn(t, i) } else t && An(e, t) }, po = (e, t, s) => { const { vnode: i, slots: n } = e; let r = !0, o = U; if (i.shapeFlag & 32) { const c = t._; c ? s && c === 1 ? r = !1 : Tn(n, t, s) : (r = !t.$stable, Cn(t, n)), o = t } else t && (An(e, t), o = { default: 1 }); if (r) for (const c in n) !Sn(c) && o[c] == null && delete n[c] }, ce = To; function go(e) { return mo(e) } function mo(e, t) { const s = Li(); s.__VUE__ = !0; const { insert: i, remove: n, patchProp: r, createElement: o, createText: c, createComment: u, setText: h, setElementText: a, parentNode: p, nextSibling: w, setScopeId: E = ke, insertStaticContent: R } = e, M = (l, f, d, b = null, g = null, m = null, x = void 0, v = null, _ = !!f.dynamicChildren) => { if (l === f) return; l && !dt(l, f) && (b = It(l), be(l, g, m, !0), l = null), f.patchFlag === -2 && (_ = !1, f.dynamicChildren = null); const { type: y, ref: S, shapeFlag: k } = f; switch (y) { case ts: ee(l, f, d, b); break; case Ze: H(l, f, d, b); break; case ms: l == null && V(f, d, b, x); break; case de: At(l, f, d, b, g, m, x, v, _); break; default: k & 1 ? J(l, f, d, b, g, m, x, v, _) : k & 6 ? Tt(l, f, d, b, g, m, x, v, _) : (k & 64 || k & 128) && y.process(l, f, d, b, g, m, x, v, _, ft) }S != null && g && ks(S, l && l.ref, m, f || l, !f) }, ee = (l, f, d, b) => { if (l == null) i(f.el = c(f.children), d, b); else { const g = f.el = l.el; f.children !== l.children && h(g, f.children) } }, H = (l, f, d, b) => { l == null ? i(f.el = u(f.children || ""), d, b) : f.el = l.el }, V = (l, f, d, b) => { [l.el, l.anchor] = R(l.children, f, d, b, l.el, l.anchor) }, K = ({ el: l, anchor: f }, d, b) => { let g; for (; l && l !== f;)g = w(l), i(l, d, b), l = g; i(f, d, b) }, C = ({ el: l, anchor: f }) => { let d; for (; l && l !== f;)d = w(l), n(l), l = d; n(f) }, J = (l, f, d, b, g, m, x, v, _) => { f.type === "svg" ? x = "svg" : f.type === "math" && (x = "mathml"), l == null ? Ie(f, d, b, g, m, x, v, _) : Ct(l, f, g, m, x, v, _) }, Ie = (l, f, d, b, g, m, x, v) => { let _, y; const { props: S, shapeFlag: k, transition: j, dirs: A } = l; if (_ = l.el = o(l.type, m, S && S.is, S), k & 8 ? a(_, l.children) : k & 16 && Oe(l.children, _, null, b, g, hs(l, m), x, v), A && We(l, null, b, "created"), me(_, l, l.scopeId, x, b), S) { for (const L in S) L !== "value" && !pt(L) && r(_, L, null, S[L], m, b); "value" in S && r(_, "value", null, S.value, m), (y = S.onVnodeBeforeMount) && _e(y, b, l) } A && We(l, null, b, "beforeMount"); const P = bo(g, j); P && j.beforeEnter(_), i(_, f, d), ((y = S && S.onVnodeMounted) || P || A) && ce(() => { y && _e(y, b, l), P && j.enter(_), A && We(l, null, b, "mounted") }, g) }, me = (l, f, d, b, g) => { if (d && E(l, d), b) for (let m = 0; m < b.length; m++)E(l, b[m]); if (g) { let m = g.subTree; if (f === m || Rn(m.type) && (m.ssContent === f || m.ssFallback === f)) { const x = g.vnode; me(l, x, x.scopeId, x.slotScopeIds, g.parent) } } }, Oe = (l, f, d, b, g, m, x, v, _ = 0) => { for (let y = _; y < l.length; y++) { const S = l[y] = v ? Re(l[y]) : we(l[y]); M(null, S, f, d, b, g, m, x, v) } }, Ct = (l, f, d, b, g, m, x) => { const v = f.el = l.el; let { patchFlag: _, dynamicChildren: y, dirs: S } = f; _ |= l.patchFlag & 16; const k = l.props || U, j = f.props || U; let A; if (d && Ve(d, !1), (A = j.onVnodeBeforeUpdate) && _e(A, d, f, l), S && We(f, l, d, "beforeUpdate"), d && Ve(d, !0), (k.innerHTML && j.innerHTML == null || k.textContent && j.textContent == null) && a(v, ""), y ? Le(l.dynamicChildren, y, v, d, b, hs(f, g), m) : x || $(l, f, v, null, d, b, hs(f, g), m, !1), _ > 0) { if (_ & 16) lt(v, k, j, d, g); else if (_ & 2 && k.class !== j.class && r(v, "class", null, j.class, g), _ & 4 && r(v, "style", k.style, j.style, g), _ & 8) { const P = f.dynamicProps; for (let L = 0; L < P.length; L++) { const D = P[L], re = k[D], q = j[D]; (q !== re || D === "value") && r(v, D, re, q, g, d) } } _ & 1 && l.children !== f.children && a(v, f.children) } else !x && y == null && lt(v, k, j, d, g); ((A = j.onVnodeUpdated) || S) && ce(() => { A && _e(A, d, f, l), S && We(f, l, d, "updated") }, b) }, Le = (l, f, d, b, g, m, x) => { for (let v = 0; v < f.length; v++) { const _ = l[v], y = f[v], S = _.el && (_.type === de || !dt(_, y) || _.shapeFlag & 70) ? p(_.el) : d; M(_, y, S, null, b, g, m, x, !0) } }, lt = (l, f, d, b, g) => { if (f !== d) { if (f !== U) for (const m in f) !pt(m) && !(m in d) && r(l, m, f[m], null, g, b); for (const m in d) { if (pt(m)) continue; const x = d[m], v = f[m]; x !== v && m !== "value" && r(l, m, v, x, g, b) } "value" in d && r(l, "value", f.value, d.value, g) } }, At = (l, f, d, b, g, m, x, v, _) => { const y = f.el = l ? l.el : c(""), S = f.anchor = l ? l.anchor : c(""); let { patchFlag: k, dynamicChildren: j, slotScopeIds: A } = f; A && (v = v ? v.concat(A) : A), l == null ? (i(y, d, b), i(S, d, b), Oe(f.children || [], d, S, g, m, x, v, _)) : k > 0 && k & 64 && j && l.dynamicChildren ? (Le(l.dynamicChildren, j, d, g, m, x, v), (f.key != null || g && f === g.subTree) && En(l, f, !0)) : $(l, f, d, S, g, m, x, v, _) }, Tt = (l, f, d, b, g, m, x, v, _) => { f.slotScopeIds = v, l == null ? f.shapeFlag & 512 ? g.ctx.activate(f, d, b, x, _) : is(f, d, b, g, m, x, _) : Qs(l, f, _) }, is = (l, f, d, b, g, m, x) => { const v = l.component = Do(l, b, g); if (pn(l) && (v.ctx.renderer = ft), Ho(v, !1, x), v.asyncDep) { if (g && g.registerDep(v, te, x), !l.el) { const _ = v.subTree = ae(Ze); H(null, _, f, d) } } else te(v, l, f, d, g, m, x) }, Qs = (l, f, d) => { const b = f.component = l.component; if (Co(l, f, d)) if (b.asyncDep && !b.asyncResolved) { B(b, f, d); return } else b.next = f, b.update(); else f.el = l.el, b.vnode = f }, te = (l, f, d, b, g, m, x) => { const v = () => { if (l.isMounted) { let { next: k, bu: j, u: A, parent: P, vnode: L } = l; { const oe = In(l); if (oe) { k && (k.el = L.el, B(l, k, x)), oe.asyncDep.then(() => { l.isUnmounted || v() }); return } } let D = k, re; Ve(l, !1), k ? (k.el = L.el, B(l, k, x)) : k = L, j && os(j), (re = k.props && k.props.onVnodeBeforeUpdate) && _e(re, P, k, L), Ve(l, !0); const q = gs(l), pe = l.subTree; l.subTree = q, M(pe, q, p(pe.el), It(pe), l, g, m), k.el = q.el, D === null && Ao(l, q.el), A && ce(A, g), (re = k.props && k.props.onVnodeUpdated) && ce(() => _e(re, P, k, L), g) } else { let k; const { el: j, props: A } = f, { bm: P, m: L, parent: D, root: re, type: q } = l, pe = mt(f); if (Ve(l, !1), P && os(P), !pe && (k = A && A.onVnodeBeforeMount) && _e(k, D, f), Ve(l, !0), j && si) { const oe = () => { l.subTree = gs(l), si(j, l.subTree, l, g, null) }; pe && q.__asyncHydrate ? q.__asyncHydrate(j, l, oe) : oe() } else { re.ce && re.ce._injectChildStyle(q); const oe = l.subTree = gs(l); M(null, oe, d, b, l, g, m), f.el = oe.el } if (L && ce(L, g), !pe && (k = A && A.onVnodeMounted)) { const oe = f; ce(() => _e(k, D, oe), g) } (f.shapeFlag & 256 || D && mt(D.vnode) && D.vnode.shapeFlag & 256) && l.a && ce(l.a, g), l.isMounted = !0, f = d = b = null } }; l.scope.on(); const _ = l.effect = new Vi(v); l.scope.off(); const y = l.update = _.run.bind(_), S = l.job = _.runIfDirty.bind(_); S.i = l, S.id = l.uid, _.scheduler = () => Ks(S), Ve(l, !0), y() }, B = (l, f, d) => { f.component = l; const b = l.vnode.props; l.vnode = f, l.next = null, fo(l, f.props, b, d), po(l, f.children, d), Ne(), di(l), $e() }, $ = (l, f, d, b, g, m, x, v, _ = !1) => { const y = l && l.children, S = l ? l.shapeFlag : 0, k = f.children, { patchFlag: j, shapeFlag: A } = f; if (j > 0) { if (j & 128) { Et(y, k, d, b, g, m, x, v, _); return } else if (j & 256) { Ue(y, k, d, b, g, m, x, v, _); return } } A & 8 ? (S & 16 && ct(y, g, m), k !== y && a(d, k)) : S & 16 ? A & 16 ? Et(y, k, d, b, g, m, x, v, _) : ct(y, g, m, !0) : (S & 8 && a(d, ""), A & 16 && Oe(k, d, b, g, m, x, v, _)) }, Ue = (l, f, d, b, g, m, x, v, _) => { l = l || tt, f = f || tt; const y = l.length, S = f.length, k = Math.min(y, S); let j; for (j = 0; j < k; j++) { const A = f[j] = _ ? Re(f[j]) : we(f[j]); M(l[j], A, d, null, g, m, x, v, _) } y > S ? ct(l, g, m, !0, !1, k) : Oe(f, d, b, g, m, x, v, _, k) }, Et = (l, f, d, b, g, m, x, v, _) => { let y = 0; const S = f.length; let k = l.length - 1, j = S - 1; for (; y <= k && y <= j;) { const A = l[y], P = f[y] = _ ? Re(f[y]) : we(f[y]); if (dt(A, P)) M(A, P, d, null, g, m, x, v, _); else break; y++ } for (; y <= k && y <= j;) { const A = l[k], P = f[j] = _ ? Re(f[j]) : we(f[j]); if (dt(A, P)) M(A, P, d, null, g, m, x, v, _); else break; k--, j-- } if (y > k) { if (y <= j) { const A = j + 1, P = A < S ? f[A].el : b; for (; y <= j;)M(null, f[y] = _ ? Re(f[y]) : we(f[y]), d, P, g, m, x, v, _), y++ } } else if (y > j) for (; y <= k;)be(l[y], g, m, !0), y++; else { const A = y, P = y, L = new Map; for (y = P; y <= j; y++) { const le = f[y] = _ ? Re(f[y]) : we(f[y]); le.key != null && L.set(le.key, y) } let D, re = 0; const q = j - P + 1; let pe = !1, oe = 0; const ut = new Array(q); for (y = 0; y < q; y++)ut[y] = 0; for (y = A; y <= k; y++) { const le = l[y]; if (re >= q) { be(le, g, m, !0); continue } let ye; if (le.key != null) ye = L.get(le.key); else for (D = P; D <= j; D++)if (ut[D - P] === 0 && dt(le, f[D])) { ye = D; break } ye === void 0 ? be(le, g, m, !0) : (ut[ye - P] = y + 1, ye >= oe ? oe = ye : pe = !0, M(le, f[ye], d, null, g, m, x, v, _), re++) } const ii = pe ? yo(ut) : tt; for (D = ii.length - 1, y = q - 1; y >= 0; y--) { const le = P + y, ye = f[le], ni = le + 1 < S ? f[le + 1].el : b; ut[y] === 0 ? M(null, ye, d, ni, g, m, x, v, _) : pe && (D < 0 || y !== ii[D] ? Be(ye, d, ni, 2) : D--) } } }, Be = (l, f, d, b, g = null) => { const { el: m, type: x, transition: v, children: _, shapeFlag: y } = l; if (y & 6) { Be(l.component.subTree, f, d, b); return } if (y & 128) { l.suspense.move(f, d, b); return } if (y & 64) { x.move(l, f, d, ft); return } if (x === de) { i(m, f, d); for (let k = 0; k < _.length; k++)Be(_[k], f, d, b); i(l.anchor, f, d); return } if (x === ms) { K(l, f, d); return } if (b !== 2 && y & 1 && v) if (b === 0) v.beforeEnter(m), i(m, f, d), ce(() => v.enter(m), g); else { const { leave: k, delayLeave: j, afterLeave: A } = v, P = () => i(m, f, d), L = () => { k(m, () => { P(), A && A() }) }; j ? j(m, P, L) : L() } else i(m, f, d) }, be = (l, f, d, b = !1, g = !1) => { const { type: m, props: x, ref: v, children: _, dynamicChildren: y, shapeFlag: S, patchFlag: k, dirs: j, cacheIndex: A } = l; if (k === -2 && (g = !1), v != null && ks(v, null, d, l, !0), A != null && (f.renderCache[A] = void 0), S & 256) { f.ctx.deactivate(l); return } const P = S & 1 && j, L = !mt(l); let D; if (L && (D = x && x.onVnodeBeforeUnmount) && _e(D, f, l), S & 6) Un(l.component, d, b); else { if (S & 128) { l.suspense.unmount(d, b); return } P && We(l, null, f, "beforeUnmount"), S & 64 ? l.type.remove(l, f, d, ft, b) : y && !y.hasOnce && (m !== de || k > 0 && k & 64) ? ct(y, f, d, !1, !0) : (m === de && k & 384 || !g && S & 16) && ct(_, f, d), b && Xs(l) } (L && (D = x && x.onVnodeUnmounted) || P) && ce(() => { D && _e(D, f, l), P && We(l, null, f, "unmounted") }, d) }, Xs = l => { const { type: f, el: d, anchor: b, transition: g } = l; if (f === de) { Ln(d, b); return } if (f === ms) { C(l); return } const m = () => { n(d), g && !g.persisted && g.afterLeave && g.afterLeave() }; if (l.shapeFlag & 1 && g && !g.persisted) { const { leave: x, delayLeave: v } = g, _ = () => x(d, m); v ? v(l.el, m, _) : _() } else m() }, Ln = (l, f) => { let d; for (; l !== f;)d = w(l), n(l), l = d; n(f) }, Un = (l, f, d) => { const { bum: b, scope: g, job: m, subTree: x, um: v, m: _, a: y } = l; yi(_), yi(y), b && os(b), g.stop(), m && (m.flags |= 8, be(x, l, f, d)), v && ce(v, f), ce(() => { l.isUnmounted = !0 }, f), f && f.pendingBranch && !f.isUnmounted && l.asyncDep && !l.asyncResolved && l.suspenseId === f.pendingId && (f.deps--, f.deps === 0 && f.resolve()) }, ct = (l, f, d, b = !1, g = !1, m = 0) => { for (let x = m; x < l.length; x++)be(l[x], f, d, b, g) }, It = l => { if (l.shapeFlag & 6) return It(l.component.subTree); if (l.shapeFlag & 128) return l.suspense.next(); const f = w(l.anchor || l.el), d = f && f[Hr]; return d ? w(d) : f }; let ns = !1; const ei = (l, f, d) => { l == null ? f._vnode && be(f._vnode, null, null, !0) : M(f._vnode || null, l, f, null, null, null, d), f._vnode = l, ns || (ns = !0, di(), un(), ns = !1) }, ft = { p: M, um: be, m: Be, r: Xs, mt: is, mc: Oe, pc: $, pbc: Le, n: It, o: e }; let ti, si; return { render: ei, hydrate: ti, createApp: oo(ei, ti) } } function hs({ type: e, props: t }, s) { return s === "svg" && e === "foreignObject" || s === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : s } function Ve({ effect: e, job: t }, s) { s ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function bo(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function En(e, t, s = !1) { const i = e.children, n = t.children; if (T(i) && T(n)) for (let r = 0; r < i.length; r++) { const o = i[r]; let c = n[r]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = n[r] = Re(n[r]), c.el = o.el), !s && c.patchFlag !== -2 && En(o, c)), c.type === ts && (c.el = o.el) } } function yo(e) { const t = e.slice(), s = [0]; let i, n, r, o, c; const u = e.length; for (i = 0; i < u; i++) { const h = e[i]; if (h !== 0) { if (n = s[s.length - 1], e[n] < h) { t[i] = n, s.push(i); continue } for (r = 0, o = s.length - 1; r < o;)c = r + o >> 1, e[s[c]] < h ? r = c + 1 : o = c; h < e[s[r]] && (r > 0 && (t[i] = s[r - 1]), s[r] = i) } } for (r = s.length, o = s[r - 1]; r-- > 0;)s[r] = o, o = t[o]; return s } function In(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : In(t) } function yi(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const _o = Symbol.for("v-scx"), vo = () => Nt(_o); function ps(e, t, s) { return On(e, t, s) } function On(e, t, s = U) { const { immediate: i, deep: n, flush: r, once: o } = s, c = Q({}, s); let u; if (ss) if (r === "sync") { const w = vo(); u = w.__watcherHandles || (w.__watcherHandles = []) } else if (!t || i) c.once = !0; else return { stop: ke, resume: ke, pause: ke }; const h = ne; c.call = (w, E, R) => je(w, h, E, R); let a = !1; r === "post" ? c.scheduler = w => { ce(w, h && h.suspense) } : r !== "sync" && (a = !0, c.scheduler = (w, E) => { E ? w() : Ks(w) }), c.augmentJob = w => { t && (w.flags |= 4), a && (w.flags |= 2, h && (w.id = h.uid, w.i = h)) }; const p = Pr(e, t, c); return u && u.push(p), p } function wo(e, t, s) { const i = this.proxy, n = G(e) ? e.includes(".") ? Pn(i, e) : () => i[e] : e.bind(i, i); let r; O(t) ? r = t : (r = t.handler, s = t); const o = St(this), c = On(n, r.bind(i), s); return o(), c } function Pn(e, t) { const s = t.split("."); return () => { let i = e; for (let n = 0; n < s.length && i; n++)i = i[s[n]]; return i } } const xo = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${qe(t)}Modifiers`] || e[`${Qe(t)}Modifiers`]; function ko(e, t, ...s) { if (e.isUnmounted) return; const i = e.vnode.props || U; let n = s; const r = t.startsWith("update:"), o = r && xo(i, t.slice(7)); o && (o.trim && (n = s.map(a => G(a) ? a.trim() : a)), o.number && (n = s.map(Jn))); let c, u = i[c = rs(t)] || i[c = rs(qe(t))]; !u && r && (u = i[c = rs(Qe(t))]), u && je(u, e, 6, n); const h = i[c + "Once"]; if (h) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, je(h, e, 6, n) } } function Mn(e, t, s = !1) { const i = t.emitsCache, n = i.get(e); if (n !== void 0) return n; const r = e.emits; let o = {}, c = !1; if (!O(e)) { const u = h => { const a = Mn(h, t, !0); a && (c = !0, Q(o, a)) }; !s && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } return !r && !c ? (W(e) && i.set(e, null), null) : (T(r) ? r.forEach(u => o[u] = null) : Q(o, r), W(e) && i.set(e, o), o) } function es(e, t) { return !e || !Kt(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), F(e, t[0].toLowerCase() + t.slice(1)) || F(e, Qe(t)) || F(e, t)) } function gs(e) { const { type: t, vnode: s, proxy: i, withProxy: n, propsOptions: [r], slots: o, attrs: c, emit: u, render: h, renderCache: a, props: p, data: w, setupState: E, ctx: R, inheritAttrs: M } = e, ee = Bt(e); let H, V; try { if (s.shapeFlag & 4) { const C = n || i, J = C; H = we(h.call(J, C, a, p, E, w, R)), V = c } else { const C = t; H = we(C.length > 1 ? C(p, { attrs: c, slots: o, emit: u }) : C(p, null)), V = t.props ? c : jo(c) } } catch (C) { yt.length = 0, Qt(C, e, 1), H = ae(Ze) } let K = H; if (V && M !== !1) { const C = Object.keys(V), { shapeFlag: J } = K; C.length && J & 7 && (r && C.some(Os) && (V = So(V, r)), K = ot(K, V, !1, !0)) } return s.dirs && (K = ot(K, null, !1, !0), K.dirs = K.dirs ? K.dirs.concat(s.dirs) : s.dirs), s.transition && Gs(K, s.transition), H = K, Bt(ee), H } const jo = e => { let t; for (const s in e) (s === "class" || s === "style" || Kt(s)) && ((t || (t = {}))[s] = e[s]); return t }, So = (e, t) => { const s = {}; for (const i in e) (!Os(i) || !(i.slice(9) in t)) && (s[i] = e[i]); return s }; function Co(e, t, s) { const { props: i, children: n, component: r } = e, { props: o, children: c, patchFlag: u } = t, h = r.emitsOptions; if (t.dirs || t.transition) return !0; if (s && u >= 0) { if (u & 1024) return !0; if (u & 16) return i ? _i(i, o, h) : !!o; if (u & 8) { const a = t.dynamicProps; for (let p = 0; p < a.length; p++) { const w = a[p]; if (o[w] !== i[w] && !es(h, w)) return !0 } } } else return (n || c) && (!c || !c.$stable) ? !0 : i === o ? !1 : i ? o ? _i(i, o, h) : !0 : !!o; return !1 } function _i(e, t, s) { const i = Object.keys(t); if (i.length !== Object.keys(e).length) return !0; for (let n = 0; n < i.length; n++) { const r = i[n]; if (t[r] !== e[r] && !es(s, r)) return !0 } return !1 } function Ao({ vnode: e, parent: t }, s) { for (; t;) { const i = t.subTree; if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e) (e = t.vnode).el = s, t = t.parent; else break } } const Rn = e => e.__isSuspense; function To(e, t) { t && t.pendingBranch ? T(e) ? t.effects.push(...e) : t.effects.push(e) : zr(e) } const de = Symbol.for("v-fgt"), ts = Symbol.for("v-txt"), Ze = Symbol.for("v-cmt"), ms = Symbol.for("v-stc"), yt = []; let ue = null; function Ae(e = !1) { yt.push(ue = e ? null : []) } function Eo() { yt.pop(), ue = yt[yt.length - 1] || null } let kt = 1; function vi(e) { kt += e, e < 0 && ue && (ue.hasOnce = !0) } function Fn(e) { return e.dynamicChildren = kt > 0 ? ue || tt : null, Eo(), kt > 0 && ue && ue.push(e), e } function Ge(e, t, s, i, n, r) { return Fn(I(e, t, s, i, n, r, !0)) } function zn(e, t, s, i, n) { return Fn(ae(e, t, s, i, n, !0)) } function Io(e) { return e ? e.__v_isVNode === !0 : !1 } function dt(e, t) { return e.type === t.type && e.key === t.key } const Dn = ({ key: e }) => e ?? null, $t = ({ ref: e, ref_key: t, ref_for: s }) => (typeof e == "number" && (e = "" + e), e != null ? G(e) || Z(e) || O(e) ? { i: xe, r: e, k: t, f: !!s } : e : null); function I(e, t = null, s = null, i = 0, n = null, r = e === de ? 0 : 1, o = !1, c = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Dn(t), ref: t && $t(t), scopeId: dn, slotScopeIds: null, children: s, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: r, patchFlag: i, dynamicProps: n, dynamicChildren: null, appContext: null, ctx: xe }; return c ? (Ys(u, s), r & 128 && e.normalize(u)) : s && (u.shapeFlag |= G(s) ? 8 : 16), kt > 0 && !o && ue && (u.patchFlag > 0 || r & 6) && u.patchFlag !== 32 && ue.push(u), u } const ae = Oo; function Oo(e, t = null, s = null, i = 0, n = null, r = !1) { if ((!e || e === Qr) && (e = Ze), Io(e)) { const c = ot(e, t, !0); return s && Ys(c, s), kt > 0 && !r && ue && (c.shapeFlag & 6 ? ue[ue.indexOf(e)] = c : ue.push(c)), c.patchFlag = -2, c } if (Uo(e) && (e = e.__vccOpts), t) { t = Po(t); let { class: c, style: u } = t; c && !G(c) && (t.class = qt(c)), W(u) && (Bs(u) && !T(u) && (u = Q({}, u)), t.style = Rs(u)) } const o = G(e) ? 1 : Rn(e) ? 128 : Nr(e) ? 64 : W(e) ? 4 : O(e) ? 2 : 0; return I(e, t, s, i, n, o, r, !0) } function Po(e) { return e ? Bs(e) || xn(e) ? Q({}, e) : e : null } function ot(e, t, s = !1, i = !1) { const { props: n, ref: r, patchFlag: o, children: c, transition: u } = e, h = t ? Ro(n || {}, t) : n, a = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: h, key: h && Dn(h), ref: t && t.ref ? s && r ? T(r) ? r.concat($t(t)) : [r, $t(t)] : $t(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: c, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== de ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: u, component: e.component, suspense: e.suspense, ssContent: e.ssContent && ot(e.ssContent), ssFallback: e.ssFallback && ot(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return u && i && Gs(a, u.clone(a)), a } function ze(e = " ", t = 0) { return ae(ts, null, e, t) } function Mo(e = "", t = !1) { return t ? (Ae(), zn(Ze, null, e)) : ae(Ze, null, e) } function we(e) { return e == null || typeof e == "boolean" ? ae(Ze) : T(e) ? ae(de, null, e.slice()) : typeof e == "object" ? Re(e) : ae(ts, null, String(e)) } function Re(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : ot(e) } function Ys(e, t) { let s = 0; const { shapeFlag: i } = e; if (t == null) t = null; else if (T(t)) s = 16; else if (typeof t == "object") if (i & 65) { const n = t.default; n && (n._c && (n._d = !1), Ys(e, n()), n._c && (n._d = !0)); return } else { s = 32; const n = t._; !n && !xn(t) ? t._ctx = xe : n === 3 && xe && (xe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else O(t) ? (t = { default: t, _ctx: xe }, s = 32) : (t = String(t), i & 64 ? (s = 16, t = [ze(t)]) : s = 8); e.children = t, e.shapeFlag |= s } function Ro(...e) { const t = {}; for (let s = 0; s < e.length; s++) { const i = e[s]; for (const n in i) if (n === "class") t.class !== i.class && (t.class = qt([t.class, i.class])); else if (n === "style") t.style = Rs([t.style, i.style]); else if (Kt(n)) { const r = t[n], o = i[n]; o && r !== o && !(T(r) && r.includes(o)) && (t[n] = r ? [].concat(r, o) : o) } else n !== "" && (t[n] = i[n]) } return t } function _e(e, t, s, i = null) { je(e, t, 7, [s, i]) } const Fo = _n(); let zo = 0; function Do(e, t, s) { const i = e.type, n = (t ? t.appContext : e.appContext) || Fo, r = { uid: zo++, vnode: e, type: i, parent: t, appContext: n, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new tr(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(n.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: jn(i, n), emitsOptions: Mn(i, n), emit: null, emitted: null, propsDefaults: U, inheritAttrs: i.inheritAttrs, ctx: U, data: U, props: U, attrs: U, slots: U, refs: U, setupState: U, setupContext: null, suspense: s, suspenseId: s ? s.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = ko.bind(null, r), e.ce && e.ce(r), r } let ne = null, Vt, Ts; { const e = Li(), t = (s, i) => { let n; return (n = e[s]) || (n = e[s] = []), n.push(i), r => { n.length > 1 ? n.forEach(o => o(r)) : n[0](r) } }; Vt = t("__VUE_INSTANCE_SETTERS__", s => ne = s), Ts = t("__VUE_SSR_SETTERS__", s => ss = s) } const St = e => { const t = ne; return Vt(e), e.scope.on(), () => { e.scope.off(), Vt(t) } }, wi = () => { ne && ne.scope.off(), Vt(null) }; function Hn(e) { return e.vnode.shapeFlag & 4 } let ss = !1; function Ho(e, t = !1, s = !1) { t && Ts(t); const { props: i, children: n } = e.vnode, r = Hn(e); co(e, i, r, t), ho(e, n, s); const o = r ? No(e, t) : void 0; return t && Ts(!1), o } function No(e, t) { const s = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Xr); const { setup: i } = s; if (i) { const n = e.setupContext = i.length > 1 ? Lo(e) : null, r = St(e); Ne(); const o = jt(i, e, 0, [e.props, n]); if ($e(), r(), zi(o)) { if (mt(e) || hn(e), o.then(wi, wi), t) return o.then(c => { xi(e, c, t) }).catch(c => { Qt(c, e, 0) }); e.asyncDep = o } else xi(e, o, t) } else Nn(e, t) } function xi(e, t, s) { O(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : W(t) && (e.setupState = ln(t)), Nn(e, s) } let ki; function Nn(e, t, s) { const i = e.type; if (!e.render) { if (!t && ki && !i.render) { const n = i.template || Js(e).template; if (n) { const { isCustomElement: r, compilerOptions: o } = e.appContext.config, { delimiters: c, compilerOptions: u } = i, h = Q(Q({ isCustomElement: r, delimiters: c }, o), u); i.render = ki(n, h) } } e.render = i.render || ke } { const n = St(e); Ne(); try { eo(e) } finally { $e(), n() } } } const $o = { get(e, t) { return X(e, "get", ""), e[t] } }; function Lo(e) { const t = s => { e.exposed = s || {} }; return { attrs: new Proxy(e.attrs, $o), slots: e.slots, emit: e.emit, expose: t } } function Zs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(ln(Sr(e.exposed)), { get(t, s) { if (s in t) return t[s]; if (s in bt) return bt[s](e) }, has(t, s) { return s in t || s in bt } })) : e.proxy } function Uo(e) { return O(e) && "__vccOpts" in e } const Bo = (e, t) => Ir(e, t, ss), Wo = "3.5.5";/**
* @vue/runtime-dom v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Es; const ji = typeof window < "u" && window.trustedTypes; if (ji) try { Es = ji.createPolicy("vue", { createHTML: e => e }) } catch { } const $n = Es ? e => Es.createHTML(e) : e => e, Vo = "http://www.w3.org/2000/svg", Ko = "http://www.w3.org/1998/Math/MathML", Ce = typeof document < "u" ? document : null, Si = Ce && Ce.createElement("template"), Go = { insert: (e, t, s) => { t.insertBefore(e, s || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, s, i) => { const n = t === "svg" ? Ce.createElementNS(Vo, e) : t === "mathml" ? Ce.createElementNS(Ko, e) : s ? Ce.createElement(e, { is: s }) : Ce.createElement(e); return e === "select" && i && i.multiple != null && n.setAttribute("multiple", i.multiple), n }, createText: e => Ce.createTextNode(e), createComment: e => Ce.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ce.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, s, i, n, r) { const o = s ? s.previousSibling : t.lastChild; if (n && (n === r || n.nextSibling)) for (; t.insertBefore(n.cloneNode(!0), s), !(n === r || !(n = n.nextSibling));); else { Si.innerHTML = $n(i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e); const c = Si.content; if (i === "svg" || i === "mathml") { const u = c.firstChild; for (; u.firstChild;)c.appendChild(u.firstChild); c.removeChild(u) } t.insertBefore(c, s) } return [o ? o.nextSibling : t.firstChild, s ? s.previousSibling : t.lastChild] } }, Jo = Symbol("_vtc"); function qo(e, t, s) { const i = e[Jo]; i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : s ? e.setAttribute("class", t) : e.className = t } const Ci = Symbol("_vod"), Yo = Symbol("_vsh"), Zo = Symbol(""), Qo = /(^|;)\s*display\s*:/; function Xo(e, t, s) { const i = e.style, n = G(s); let r = !1; if (s && !n) { if (t) if (G(t)) for (const o of t.split(";")) { const c = o.slice(0, o.indexOf(":")).trim(); s[c] == null && Lt(i, c, "") } else for (const o in t) s[o] == null && Lt(i, o, ""); for (const o in s) o === "display" && (r = !0), Lt(i, o, s[o]) } else if (n) { if (t !== s) { const o = i[Zo]; o && (s += ";" + o), i.cssText = s, r = Qo.test(s) } } else t && e.removeAttribute("style"); Ci in e && (e[Ci] = r ? i.display : "", e[Yo] && (i.display = "none")) } const Ai = /\s*!important$/; function Lt(e, t, s) { if (T(s)) s.forEach(i => Lt(e, t, i)); else if (s == null && (s = ""), t.startsWith("--")) e.setProperty(t, s); else { const i = el(e, t); Ai.test(s) ? e.setProperty(Qe(i), s.replace(Ai, ""), "important") : e[i] = s } } const Ti = ["Webkit", "Moz", "ms"], bs = {}; function el(e, t) { const s = bs[t]; if (s) return s; let i = qe(t); if (i !== "filter" && i in e) return bs[t] = i; i = Ni(i); for (let n = 0; n < Ti.length; n++) { const r = Ti[n] + i; if (r in e) return bs[t] = r } return t } const Ei = "http://www.w3.org/1999/xlink"; function Ii(e, t, s, i, n, r = er(t)) { i && t.startsWith("xlink:") ? s == null ? e.removeAttributeNS(Ei, t.slice(6, t.length)) : e.setAttributeNS(Ei, t, s) : s == null || r && !Ui(s) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : He(s) ? String(s) : s) } function tl(e, t, s, i) { if (t === "innerHTML" || t === "textContent") { s != null && (e[t] = t === "innerHTML" ? $n(s) : s); return } const n = e.tagName; if (t === "value" && n !== "PROGRESS" && !n.includes("-")) { const o = n === "OPTION" ? e.getAttribute("value") || "" : e.value, c = s == null ? e.type === "checkbox" ? "on" : "" : String(s); (o !== c || !("_value" in e)) && (e.value = c), s == null && e.removeAttribute(t), e._value = s; return } let r = !1; if (s === "" || s == null) { const o = typeof e[t]; o === "boolean" ? s = Ui(s) : s == null && o === "string" ? (s = "", r = !0) : o === "number" && (s = 0, r = !0) } try { e[t] = s } catch { } r && e.removeAttribute(t) } function sl(e, t, s, i) { e.addEventListener(t, s, i) } function il(e, t, s, i) { e.removeEventListener(t, s, i) } const Oi = Symbol("_vei"); function nl(e, t, s, i, n = null) { const r = e[Oi] || (e[Oi] = {}), o = r[t]; if (i && o) o.value = i; else { const [c, u] = rl(t); if (i) { const h = r[t] = cl(i, n); sl(e, c, h, u) } else o && (il(e, c, o, u), r[t] = void 0) } } const Pi = /(?:Once|Passive|Capture)$/; function rl(e) { let t; if (Pi.test(e)) { t = {}; let i; for (; i = e.match(Pi);)e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Qe(e.slice(2)), t] } let ys = 0; const ol = Promise.resolve(), ll = () => ys || (ol.then(() => ys = 0), ys = Date.now()); function cl(e, t) { const s = i => { if (!i._vts) i._vts = Date.now(); else if (i._vts <= s.attached) return; je(fl(i, s.value), t, 5, [i]) }; return s.value = e, s.attached = ll(), s } function fl(e, t) { if (T(t)) { const s = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { s.call(e), e._stopped = !0 }, t.map(i => n => !n._stopped && i && i(n)) } else return t } const Mi = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, ul = (e, t, s, i, n, r) => { const o = n === "svg"; t === "class" ? qo(e, i, o) : t === "style" ? Xo(e, s, i) : Kt(t) ? Os(t) || nl(e, t, s, i, r) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : al(e, t, i, o)) ? (tl(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Ii(e, t, i, o, r, t !== "value")) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), Ii(e, t, i, o)) }; function al(e, t, s, i) { if (i) return !!(t === "innerHTML" || t === "textContent" || t in e && Mi(t) && O(s)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const n = e.tagName; if (n === "IMG" || n === "VIDEO" || n === "CANVAS" || n === "SOURCE") return !1 } return Mi(t) && G(s) ? !1 : !!(t in e || e._isVueCE && (/[A-Z]/.test(t) || !G(s))) } const dl = Q({ patchProp: ul }, Go); let Ri; function hl() { return Ri || (Ri = go(dl)) } const pl = (...e) => { const t = hl().createApp(...e), { mount: s } = t; return t.mount = i => { const n = ml(i); if (!n) return; const r = t._component; !O(r) && !r.render && !r.template && (r.template = n.innerHTML), n.nodeType === 1 && (n.textContent = ""); const o = s(n, !1, gl(n)); return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), o }, t }; function gl(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function ml(e) { return G(e) ? document.querySelector(e) : e } const bl = ["href"], yl = ["href", "aria-label"], _l = ["src", "alt"], vl = ["href"], wl = { __name: "project", props: { name: String, link: String, image: String, description: String, skills: String, categories: String, repo: String }, setup(e) { return (t, s) => (Ae(), Ge(de, null, [I("link", { rel: "preload", fetchpriority: "high", as: "image", href: e.image === "" ? "https://placeholder.co/600x400/?text=NoImage" : e.image, type: "image/png" }, null, 8, bl), I("div", { class: qt(["item "].concat(e.categories.split(" "))) }, [I("a", { href: e.link, "aria-label": "See the site for " + e.name }, [I("img", { src: e.image === "" ? "https://placeholder.co/600x400/?text=NoImage" : e.image, alt: "Project photo for" + e.name }, null, 8, _l), I("h4", null, [ze(Ht(e.name), 1), e.repo ? (Ae(), Ge("a", { key: 0, href: e.repo, style: { display: "inline-block", "margin-left": "10px" } }, s[0] || (s[0] = [I("img", { src: "https://jdszekeres.github.io/project-photos/github-mark-white.svg", style: { width: "32px" } }, null, -1)]), 8, vl)) : Mo("", !0)])], 8, yl), I("p", null, Ht(e.description), 1), I("p", null, [s[2] || (s[2] = ze("skills learned:")), (Ae(!0), Ge(de, null, bn(e.skills.split(","), (i, n) => (Ae(), Ge("span", { key: n }, [I("em", null, [s[1] || (s[1] = I("br", null, null, -1)), ze(Ht(i), 1)])]))), 128))])], 2)], 64)) } }, xl = ["href"], kl = ["src"], Dt = { __name: "imagelink", props: { link: String, image: String }, setup(e) { return (t, s) => (Ae(), Ge("a", { href: e.link, style: { "text-decoration": "none", display: "block" } }, [I("img", { src: e.image, alt: "linkedin", style: { width: "64px" } }, null, 8, kl), s[0] || (s[0] = ze("   "))], 8, xl)) } }, jl = (e, t) => { const s = e.__vccOpts || e; for (const [i, n] of t) s[i] = n; return s }, Sl = { style: { height: "100vh", display: "flex" } }, Cl = { style: { width: "50vw", display: "flex", "justify-content": "end", "flex-wrap": "wrap" } }, Al = { style: { display: "flex", "justify-content": "center", width: "100%", "align-content": "start" } }, Tl = { id: "hobbys" }, El = { style: { width: "100%", display: "flex", "justify-content": "center" } }, Il = { id: "projects" }, Ol = { __name: "App", setup(e) { const t = as([{ name: "Airport Game", skills: "JSON,leaderboard", categories: "c a fav", link: "https://jdszekeres.github.io/airport.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/airport-game.png", description: "Try to guess all the airports in the US (There's over 350)" }, { name: "Chess.com Stats", skills: "API,graphs", categories: "c", link: "https://jdszekeres.github.io/chesscom.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/chesscom-stats.png", description: "Uses chess.com open database to look at your chess skills statistically" }, { name: "Pixel Art Color by Number", skills: "JSON,user settings,UI design", categories: "c fav", link: "https://jdszekeres.github.io/pixelart.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/pixel-color-by-number.png", description: "A color by number game on a 32x32 grid" }, { name: "Reigonle", skills: "maps,wordle style random generation", categories: "c g fav", link: "https://jdszekeres.github.io/reigonle.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/reigonle.png", description: "A wordle type game where you guess a country every day to fill in your map" }, { name: "War ♤♧♡♢", skills: "API", categories: "c", link: "https://jdszekeres.github.io/war.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/war-cards.png", description: "To prove war is all luck, play this bot." }, { name: "Word Guess", skills: "wordle style random generation,API", categories: "c", link: "https://jdszekeres.github.io/wordguess.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/word-guess.png", description: "A wordle type game where you guess a word by searching for synomyns and rythming words" }, { name: "Machine Learning Class", skills: "machine learning", categories: "c", link: "https://jdszekeres.github.io/ml.html", image: "", description: "ML program for a class I took" }, { name: "Chrome Startup Screen", skills: "perlin noise, reverse engineering", categories: "c fav", link: "https://jdszekeres.github.io/chrome.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/browser-start-screen.png", description: "A start screen that includes all the strange holidays and a procedural heightmap gradient", repo: "https://github.com/jdszekeres/chrome-wallpaper" }, { name: "Projectile Motion Calc", skills: "trig", categories: "c", link: "https://jdszekeres.github.io/projectile%20motion.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/projectile-motion.png", description: "A calculator that calculates projectile motion based on Firing Angle and Exit Speed" }, { name: "Wage counter", skills: "setInterval,setTimeout", categories: "c", link: "https://jdszekeres.github.io/wage.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/income-clock.png", description: "A timer that calculates how much you earn" }, { name: "Space Invader", skills: "pygame", categories: "c", link: "https://github.com/jdszekeres/space-invader", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/space-invader.png", description: "Space invaders in python (Multiple Levels)" }, { name: "EZL", skills: "lexing", categories: "c", link: "https://github.com/jdszekeres/ezl", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/ezl.png", description: "A mini programming language interperted in python" }, { name: "FlaskEnv", skills: "bash download", categories: "c", link: "https://github.com/jdszekeres/flaskenv", image: "", description: "Easily create a mini flask enviroment" }, { name: "Window Seat Simulator", skills: "maps,API,Mapbox", categories: "c a fav", link: "https://github.com/jdszekeres/windowseat", image: "https://jdszekeres.github.io/project-photos/windowseat.jpg", description: "A program that uses angled satelite imagery to simulate the view outside of a plane", repo: "https://github.com/jdszekeres/windowseat" }, { name: "Choose Your Own Adventure", skills: "recursion,story telling", categories: "c", link: "https://replit.com/@wong-csf-f23-p1/U109c-Python-Adventure-Project-jdszekeres?embed=true", image: "https://t3.ftcdn.net/jpg/06/22/07/90/360_F_622079039_2mFtFQpSv7Z9hdcDdWHj1eTNZIwQP5Z0.jpg", description: "A chose your own adventure for my CS class. Ms. Wong why didn't you tell me we didn't we didn't need 4³ endings?" }, { name: "City Builder", skills: "sqlite,pixel art", categories: "c g", link: "https://github.com/jdszekeres/city-builder", image: "https://jdszekeres.github.io/project-photos/city-builder.png", description: "A clone of Sim City build it in the browser with subpar graphics" }, { name: "City Builder 2: electric boogaloo", skills: "JSON,pixel art,UI design", categories: "c g", link: "https://github.com/jdszekeres/citybuilder2.0", image: "https://jdszekeres.github.io/project-photos/citybuilder2.png", description: "A more complex better looking (At least that's what I tell myself) version on citybuilder1.0" }, { name: "Gimkit Pratice Test", skills: "reverse engineering,bootstrap", categories: "c", link: "https://jdszekeres.github.io/gimkittest.html", image: "https://jdszekeres.github.io/project-photos/gimkit.png", description: "A reskinned version of Gimkit practice questions" }, { name: "Spotify Game", skills: "API,oauth", categories: "c fav", link: "https://jdszekeres.github.io/spotify.html", image: "https://jdszekeres.github.io/project-photos/spotify.png", description: "A spotify game that uses the spotify API to get your playlists and quiz you on how well you know your playlists" }, { name: "Trivia", skills: "API", categories: "c", link: "https://jdszekeres.github.io/trivia.html", image: "https://jdszekeres.github.io/project-photos/trivia.png", description: "A trivia game that uses the trivia api" }, { name: "dispenser", skills: "CAD", categories: "3", link: "https://www.thingiverse.com/thing:6286816", image: "", description: "A dispenser for solid objects" }, { name: "All Things Dashboard", skills: "API,reverse enginnering,UI design,user settings", categories: "c fav", link: "https://allthingsdashboard.vercel.app/settings", image: "https://jdszekeres.github.io/project-photos/allthingsdashboard.png", description: "A central dashboard to integrate your favorite data sources into one view" }, { name: "IOCCC Hacker Type Feed", skills: "scraping", categories: "c", link: "https://replit.com/@jdszekeres/IOCCC-Hacker-Type?", image: "https://jdszekeres.github.io/project-photos/hackerType.png", description: "Generates a file you can upload to hackertype.net to use ioccc data (It looks much better)" }, { name: "Aeries Parser", skills: "reverse engineering,API", categories: "c", link: "https://jdszekeres.github.io/aeriesparser.html", image: "https://jdszekeres.github.io/project-photos/aeriesparser.png", description: "A parser for the popular SIS program Aeries that gets a static version of the site and allows it to do thing like calculate final grades." }, { name: "Ticking Timer", skills: "audio", categories: "c", link: "https://jdszekeres.github.io/tickingtimer.html", image: "", description: "A timer that counts down to a set time with a ticking sound. Made for my English teacher.", repo: "https://github.com/jdszekeres/Tick-Timer" }, { name: "Trail Markers", skills: "UI Design, Figma, file upload", categories: "c g", link: "https://jdszekeres.github.io/strava.html", image: "https://raw.githubusercontent.com/jdszekeres/trailMarkers/main/screenshot.png", description: "A website that allows you to upload a running route and calculates how much time it takes you to run an individual section", repo: "https://github.com/jdszekeres/trailMarkers" }, { name: "Köppen Flights", skills: "Turfjs, tailwind, geoJSON, UI Design", categories: "c g a", link: "https://jdszekeres.github.io/koppenFlight.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/koppenFlight.png", description: "A website that allow you to examine the distribution of Köppen-Geiger climate zones across a flight path", repo: "https://github.com/jdszekeres/koppenFlights" }, { name: "Virtual Real Estate", skills: "API, THREE.js, leaflet, UI Design", categories: "c g fav", link: "https://jdszekeres.github.io/virtualRealEstate/", image: "https://jdszekeres.github.io/project-photos/virtualRealEstate.png", description: "A site that allow you to model a house or building on a piece of virtual land based on satelite imagery", repo: "https://github.com/jdszekeres/virtualRealEstate" }, { name: "Correct Horse Battery Staple Password Generator", skills: "API, pure-css", categories: "c", link: "https://jdszekeres.github.io/passwordEntropy.html", image: "", description: "A password generator that allow you to drop in categories of words" }, { name: "Top Down Geography Guesser", skills: "API, map, nodejs, express, adsense", categories: "c g a fav", link: "https://top-down-geo-guesser.vercel.app/", image: "https://jdszekeres.github.io/project-photos/geo-guesser.png", description: "A site similar to geo guesser, but it presents locations in the form of tiles", repo: "https://github.com/jdszekeres/top-down-geo-guesser" }, { name: "Custom 2048", skills: "JS, Readme, ChatGPT, reverse engineering", categories: "c", link: "https://jdszekeres.github.io/2048.html", image: "https://repository-images.githubusercontent.com/874544784/e30592d3-9781-42f5-a250-89fe50524067", description: "A github template that allows you to customize the game 2048 to your liking", repo: "https://github.com/jdszekeres/custom-2048" }]); let s = as([]), i = as(t.value); function n(r) { const o = s.value.includes(r); s.value = [], !o && r !== "" && s.value.push(r), i.value = t.value.filter(c => s.value.length === 0 || c.categories.split(" ").some(u => u === r)) } return (r, o) => (Ae(), Ge("main", null, [I("div", Sl, [o[9] || (o[9] = I("div", { style: { width: "49vw" } }, [I("h1", { style: { "text-align": "left" } }, "👋Hi, I'm jdszekeres👋"), I("h2", { style: { "text-align": "unset" } }, [ze("Right now, I'm a Sophmore in High School with an interest in Computer Science🧑‍💻, Geography🗺️, aviation✈️ and 3D printing🖨️🪴. My favorite programming languages are "), I("code", null, "Python && Javascript"), ze(". If I'm not glued to a screen, you can find me running🏃‍♂️, biking🚵, hiking or exploring the great outdoors🌄. ")])], -1)), I("div", Cl, [o[5] || (o[5] = I("h3", { style: { "text-align": "center", width: "100%" } }, "You can look for me here:", -1)), I("div", Al, [ae(Dt, { link: "www.linkedin.com/in/jdszekeres", image: "LI-logo.png" }), ae(Dt, { link: "https://github.com/jdszekeres", image: "github-mark.svg" }), ae(Dt, { link: "https://github.com/CCA-AppDev", image: "cca-appdev.png" }), ae(Dt, { link: "https://leetcode.com/u/jdszekeres/", image: "leetcode.png" })]), o[6] || (o[6] = I("h3", { style: { "text-align": "center", width: "100%" } }, "Here are some projects I'm working on right now.", -1)), o[7] || (o[7] = I("div", { style: { width: "100%", display: "flex", "flex-wrap": "wrap", "justify-content": "center" } }, [I("img", { src: "https://github-readme-stats.vercel.app/api/pin/?username=jdszekeres&repo=top-down-geo-guesser&theme=radical" }), I("img", { src: "https://github-readme-stats.vercel.app/api/pin/?username=jdszekeres&repo=custom-2048&theme=radical" })], -1)), o[8] || (o[8] = I("p", null, null, -1))]), o[10] || (o[10] = I("h3", { style: { "text-align": "center", width: "100%", position: "absolute", bottom: "0" } }, [ze(" more projects down here"), I("br"), I("span", { class: "pulse" }, "▽")], -1))]), o[13] || (o[13] = I("h3", { style: { "font-size": "36px" } }, "my hobbies include", -1)), I("div", Tl, [I("button", { class: "hobby", id: "cs", onClick: o[0] || (o[0] = c => n("c")), style: { "min-width": "250px !important" } }, o[11] || (o[11] = [I("div", { id: "hack" }, "Computer Science", -1)])), I("button", { class: "hobby", onClick: o[1] || (o[1] = c => n("a")), style: { width: "150px" } }, o[12] || (o[12] = [I("div", { id: "aviation" }, "aviation", -1)])), I("button", { class: "hobby", onClick: o[2] || (o[2] = c => n("3")), id: "printing" }, "3D printing"), I("button", { class: "hobby", onClick: o[3] || (o[3] = c => n("g")), id: "geo" }, "Geography")]), I("div", El, [I("button", { class: "hobby", onClick: o[4] || (o[4] = c => n("fav")) }, "My Favorite Projects")]), I("div", Il, [(Ae(!0), Ge(de, null, bn(on(i), (c, u) => (Ae(), zn(wl, { key: u, skills: c.skills, categories: c.categories, name: c.name, link: c.link, image: c.image, description: c.description, repo: c.repo }, null, 8, ["skills", "categories", "name", "link", "image", "description", "repo"]))), 128))])])) } }, Pl = jl(Ol, [["__scopeId", "data-v-89bacd34"]]); pl(Pl).mount("#app");
    </script>
    <style rel="stylesheet" crossorigin>
        @import"https://fonts.googleapis.com/css2?family=Fira+Code&family=Roboto:wght@500&display=swap";
        @media screen and (orientation:portrait) {
            a {
                font-size: 15px;
                overflow: scroll
            }

            p {
                font-size: 12px
            }

            .item {
                width: calc(50% - 20px)
            }
        }

        .item {
            width: calc((100% / 3) - (5px * 3));
            height: 50%;
            padding: 5px
        }

        img {
            width: min(100%, 500px)
        }

        h4 {
            width: 100%;
            text-align: center;
            font-family: Fira Code, Roboto, sans-serif
        }

        a {
            font-size: 25px
        }

        p {
            width: 100%;
            color: #dcdcdc;
            font-size: 16px;
            font-weight: 700
        }

        @media (hover: hover) {
            a:hover {
                background-color: transparent
            }
        }

        @media screen and (orientation:portrait) {
            .hobbdy[data-v-89bacd34] {
                width: 100%
            }
        }

        #projects[data-v-89bacd34] {
            display: flex;
            flex-wrap: wrap
        }

        h1[data-v-89bacd34] {
            font-weight: 800;
            font-size: 64px;
            font-family: roboto;
            width: 100%;
            text-align: center;
            color: radial-gradient(circle, rgba(41, 41, 39, 1) 0%, rgba(64, 59, 14, 1) 100%)
        }

        h2[data-v-89bacd34],
        h3[data-v-89bacd34] {
            text-align: center
        }

        #hobbys[data-v-89bacd34] {
            margin: auto;
            text-align: center;
            width: 100%;
            overflow-wrap: wrap
        }

        .hobby[data-v-89bacd34] {
            margin: 10px;
            padding: 10px;
            font-size: 22px;
            background: none;
            border: 3px solid black;
            height: 50.4px;
            position: relative
        }

        #cs[data-v-89bacd34] {
            color: #78ff78;
            min-width: 200px
        }

        #hack[data-v-89bacd34] {
            font-family: monospace;
            font-size: 20px;
            white-space: nowrap;
            text-shadow: 0 2px 2px rgba(#000, .9)
        }

        @keyframes landing-89bacd34 {
            0% {
                transform: translate3d(-30%, -30%, 0)
            }

            to {
                transform: translate3d(30%, 35%, 0)
            }
        }

        #aviation[data-v-89bacd34] {
            animation: landing-89bacd34 2s ease-in-out infinite
        }

        #geo[data-v-89bacd34] {
            background-image: url(geography.gif);
            background-size: cover
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #2f3454;
                background: radial-gradient(circle, #2f3454, #445278)
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                background: #6f7bc8;
                background: radial-gradient(circle, #6f7bc8, #607abe)
            }
        }

        a,
        .green {
            text-decoration: none;
            color: #00bd7e;
            transition: .4s
        }

        .pulse {
            display: block !important;
            animation: pulse 2s ease-in-out infinite
        }

        @keyframes pulse {
            0% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.2)
            }

            to {
                transform: scale(1)
            }
        }
    </style>
</head>

<body style="overflow-x: hidden;">
    <div id="app">

    </div>
</body>
<script>
    class Messenger {
        constructor(el) {
            this.el = el
            this.codeletters = "abcdefghijklmnopqrstuvwxyz1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            this.message = 0;
            this.currentLength = 0;
            this.fadeBuffer = false;
            this.messages = [
                'Computer Science',
                'Machine Learning',
                'Web Development',
                'IOS Development',
                'Cryptography'
            ];

            setTimeout(() => this.animateIn(), 100);
        }

        generateRandomString(length) {
            var randomText = "";
            while (randomText.length < length) {
                randomText += this.codeletters.charAt(Math.floor(Math.random() * this.codeletters.length));
            }

            return randomText;
        }

        animateIn() {
            if (this.currentLength < this.messages[this.message].length) {
                this.currentLength += 2;
                if (this.currentLength > this.messages[this.message].length) {
                    this.currentLength = this.messages[this.message].length;
                }

                var message = this.generateRandomString(this.currentLength);
                this.el.innerHTML = message;

                setTimeout(() => this.animateIn(), 20);
            } else {
                setTimeout(() => this.animateFadeBuffer(), 20);
            }
        }

        animateFadeBuffer() {
            if (!this.fadeBuffer) {
                this.fadeBuffer = [];
                for (let i = 0; i < this.messages[this.message].length; i++) {
                    this.fadeBuffer.push({
                        c: Math.floor(Math.random() * 12) + 1,
                        l: this.messages[this.message].charAt(i)
                    });
                }
            }

            let doCycles = false;
            let message = "";

            for (let i = 0; i < this.fadeBuffer.length; i++) {
                var fader = this.fadeBuffer[i];
                if (fader.c > 0) {
                    doCycles = true;
                    fader.c--;
                    message += this.codeletters.charAt(Math.floor(Math.random() * this.codeletters.length));
                } else {
                    message += fader.l;
                }
            }

            this.el.innerHTML = message;

            if (doCycles) {
                setTimeout(() => this.animateFadeBuffer(), 50);
            } else {
                setTimeout(() => this.cycleText(), 2000);
            }
        }

        cycleText() {
            this.message++;
            if (this.message >= this.messages.length) {
                this.message = 0;
            }

            this.currentLength = 0;
            this.fadeBuffer = false;
            this.el.innerHTML = "";

            setTimeout(() => this.animateIn(), 200);
        }

        init() {
            this.animateIn();
        }
    }


    setTimeout(() => new Messenger(document.getElementById('cs')), 1000)

    function updateBackground(element, progress) {
        style = element.style;
        style.background = `linear-gradient(0deg,rgb(0,0,0) 0%,rgb(0, 0, 0) ${progress}%,rgb(255,255,255) ${progress + 0.01}%, rgb(255, 255, 255) 100%)`;
        style.backgroundColor = "#000";
        style.backgroundSize = "100%";
        style.backgroundRepeat = "repeat";

        // Set the background to be clipped to the text and transparent
        style.webkitBackgroundClip = "text";
        style.webkitTextFillColor = "transparent";
        style.mozBackgroundClip = "text";
        style.mozTextFillColor = "transparent";

    }

    count = 0;
    setTimeout(() => {
        setInterval(() => {
            count++;
            count = count % 100;
            updateBackground(document.getElementById('printing'), count);
        }, 50)
    }, 1000)
</script>

</html>