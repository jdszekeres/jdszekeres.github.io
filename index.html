<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Projects</title>
    <script type="module" crossorigin>(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const r of i) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function s(i) { const r = {}; return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function n(i) { if (i.ep) return; i.ep = !0; const r = s(i); fetch(i.href, r) } })();/**
* @vue/shared v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Os(e) { const t = Object.create(null); for (const s of e.split(",")) t[s] = 1; return s => s in t } const U = {}, Qe = [], Se = () => { }, Ui = () => !1, Kt = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Is = e => e.startsWith("onUpdate:"), Q = Object.assign, Ps = (e, t) => { const s = e.indexOf(t); s > -1 && e.splice(s, 1) }, Bi = Object.prototype.hasOwnProperty, R = (e, t) => Bi.call(e, t), T = Array.isArray, Xe = e => Vt(e) === "[object Map]", zn = e => Vt(e) === "[object Set]", O = e => typeof e == "function", G = e => typeof e == "string", ze = e => typeof e == "symbol", W = e => e !== null && typeof e == "object", Dn = e => (W(e) || O(e)) && O(e.then) && O(e.catch), Hn = Object.prototype.toString, Vt = e => Hn.call(e), Wi = e => Vt(e).slice(8, -1), Nn = e => Vt(e) === "[object Object]", Ms = e => G(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, dt = Os(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Gt = e => { const t = Object.create(null); return s => t[s] || (t[s] = e(s)) }, Ki = /-(\w)/g, Ge = Gt(e => e.replace(Ki, (t, s) => s ? s.toUpperCase() : "")), Vi = /\B([A-Z])/g, Je = Gt(e => e.replace(Vi, "-$1").toLowerCase()), $n = Gt(e => e.charAt(0).toUpperCase() + e.slice(1)), is = Gt(e => e ? `on${$n(e)}` : ""), Fe = (e, t) => !Object.is(e, t), rs = (e, ...t) => { for (let s = 0; s < e.length; s++)e[s](...t) }, Ln = (e, t, s, n = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: n, value: s }) }, Gi = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let on; const Un = () => on || (on = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Rs(e) { if (T(e)) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s], i = G(n) ? Zi(n) : Rs(n); if (i) for (const r in i) t[r] = i[r] } return t } else if (G(e) || W(e)) return e } const qi = /;(?![^(]*\))/g, Ji = /:([^]+)/, Yi = /\/\*[^]*?\*\//g; function Zi(e) { const t = {}; return e.replace(Yi, "").split(qi).forEach(s => { if (s) { const n = s.split(Ji); n.length > 1 && (t[n[0].trim()] = n[1].trim()) } }), t } function qt(e) { let t = ""; if (G(e)) t = e; else if (T(e)) for (let s = 0; s < e.length; s++) { const n = qt(e[s]); n && (t += n + " ") } else if (W(e)) for (const s in e) e[s] && (t += s + " "); return t.trim() } const Qi = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Xi = Os(Qi); function Bn(e) { return !!e || e === "" } const Wn = e => !!(e && e.__v_isRef === !0), zt = e => G(e) ? e : e == null ? "" : T(e) || W(e) && (e.toString === Hn || !O(e.toString)) ? Wn(e) ? zt(e.value) : JSON.stringify(e, Kn, 2) : String(e), Kn = (e, t) => Wn(t) ? Kn(e, t.value) : Xe(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((s, [n, i], r) => (s[os(n, r) + " =>"] = i, s), {}) } : zn(t) ? { [`Set(${t.size})`]: [...t.values()].map(s => os(s)) } : ze(t) ? os(t) : W(t) && !T(t) && !Nn(t) ? String(t) : t, os = (e, t = "") => { var s; return ze(e) ? `Symbol(${(s = e.description) != null ? s : t})` : e };/**
* @vue/reactivity v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let fe; class er { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = fe, !t && fe && (this.index = (fe.scopes || (fe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].pause(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, s; if (this.scopes) for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].resume(); for (t = 0, s = this.effects.length; t < s; t++)this.effects[t].resume() } } run(t) { if (this._active) { const s = fe; try { return fe = this, t() } finally { fe = s } } } on() { fe = this } off() { fe = this.parent } stop(t) { if (this._active) { let s, n; for (s = 0, n = this.effects.length; s < n; s++)this.effects[s].stop(); for (s = 0, n = this.cleanups.length; s < n; s++)this.cleanups[s](); if (this.scopes) for (s = 0, n = this.scopes.length; s < n; s++)this.scopes[s].stop(!0); if (!this.detached && this.parent && !t) { const i = this.parent.scopes.pop(); i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index) } this.parent = void 0, this._active = !1 } } } function tr() { return fe } let H; const ls = new WeakSet; class Vn { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.nextEffect = void 0, this.cleanup = void 0, this.scheduler = void 0, fe && fe.active && fe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, ls.has(this) && (ls.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || (this.flags |= 8, this.nextEffect = ht, ht = this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, ln(this), qn(this); const t = H, s = pe; H = this, pe = !0; try { return this.fn() } finally { Jn(this), H = t, pe = s, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Ds(t); this.deps = this.depsTail = void 0, ln(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? ls.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { _s(this) && this.run() } get dirty() { return _s(this) } } let Gn = 0, ht; function Fs() { Gn++ } function zs() { if (--Gn > 0) return; let e; for (; ht;) { let t = ht; for (ht = void 0; t;) { const s = t.nextEffect; if (t.nextEffect = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (n) { e || (e = n) } t = s } } if (e) throw e } function qn(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Jn(e) { let t, s = e.depsTail, n = s; for (; n;) { const i = n.prevDep; n.version === -1 ? (n === s && (s = i), Ds(n), sr(n)) : t = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = i } e.deps = t, e.depsTail = s } function _s(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && Yn(t.dep.computed) || t.dep.version !== t.version) return !0; return !!e._dirty } function Yn(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === bt)) return; e.globalVersion = bt; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && !_s(e)) { e.flags &= -3; return } const s = H, n = pe; H = e, pe = !0; try { qn(e); const i = e.fn(e._value); (t.version === 0 || Fe(i, e._value)) && (e._value = i, t.version++) } catch (i) { throw t.version++, i } finally { H = s, pe = n, Jn(e), e.flags &= -3 } } function Ds(e) { const { dep: t, prevSub: s, nextSub: n } = e; if (s && (s.nextSub = n, e.prevSub = void 0), n && (n.prevSub = s, e.nextSub = void 0), t.subs === e && (t.subs = s), !t.subs && t.computed) { t.computed.flags &= -5; for (let i = t.computed.deps; i; i = i.nextDep)Ds(i) } } function sr(e) { const { prevDep: t, nextDep: s } = e; t && (t.nextDep = s, e.prevDep = void 0), s && (s.prevDep = t, e.nextDep = void 0) } let pe = !0; const Zn = []; function De() { Zn.push(pe), pe = !1 } function He() { const e = Zn.pop(); pe = e === void 0 ? !0 : e } function ln(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const s = H; H = void 0; try { t() } finally { H = s } } } let bt = 0; class nr { constructor(t, s) { this.sub = t, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Hs { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0 } track(t) { if (!H || !pe || H === this.computed) return; let s = this.activeLink; if (s === void 0 || s.sub !== H) s = this.activeLink = new nr(H, this), H.deps ? (s.prevDep = H.depsTail, H.depsTail.nextDep = s, H.depsTail = s) : H.deps = H.depsTail = s, H.flags & 4 && Qn(s); else if (s.version === -1 && (s.version = this.version, s.nextDep)) { const n = s.nextDep; n.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = n), s.prevDep = H.depsTail, s.nextDep = void 0, H.depsTail.nextDep = s, H.depsTail = s, H.deps === s && (H.deps = n) } return s } trigger(t) { this.version++, bt++, this.notify(t) } notify(t) { Fs(); try { for (let s = this.subs; s; s = s.prevSub)s.sub.notify() } finally { zs() } } } function Qn(e) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let n = t.deps; n; n = n.nextDep)Qn(n) } const s = e.dep.subs; s !== e && (e.prevSub = s, s && (s.nextSub = e)), e.dep.subs = e } const vs = new WeakMap, Ke = Symbol(""), xs = Symbol(""), yt = Symbol(""); function X(e, t, s) { if (pe && H) { let n = vs.get(e); n || vs.set(e, n = new Map); let i = n.get(s); i || n.set(s, i = new Hs), i.track() } } function Ae(e, t, s, n, i, r) { const o = vs.get(e); if (!o) { bt++; return } const c = u => { u && u.trigger() }; if (Fs(), t === "clear") o.forEach(c); else { const u = T(e), h = u && Ms(s); if (u && s === "length") { const a = Number(n); o.forEach((p, x) => { (x === "length" || x === yt || !ze(x) && x >= a) && c(p) }) } else switch (s !== void 0 && c(o.get(s)), h && c(o.get(yt)), t) { case "add": u ? h && c(o.get("length")) : (c(o.get(Ke)), Xe(e) && c(o.get(xs))); break; case "delete": u || (c(o.get(Ke)), Xe(e) && c(o.get(xs))); break; case "set": Xe(e) && c(o.get(Ke)); break } } zs() } function Ye(e) { const t = F(e); return t === e ? t : (X(t, "iterate", yt), de(e) ? t : t.map(Y)) } function Jt(e) { return X(e = F(e), "iterate", yt), e } const ir = { __proto__: null, [Symbol.iterator]() { return cs(this, Symbol.iterator, Y) }, concat(...e) { return Ye(this).concat(...e.map(t => T(t) ? Ye(t) : t)) }, entries() { return cs(this, "entries", e => (e[1] = Y(e[1]), e)) }, every(e, t) { return ke(this, "every", e, t, void 0, arguments) }, filter(e, t) { return ke(this, "filter", e, t, s => s.map(Y), arguments) }, find(e, t) { return ke(this, "find", e, t, Y, arguments) }, findIndex(e, t) { return ke(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return ke(this, "findLast", e, t, Y, arguments) }, findLastIndex(e, t) { return ke(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return ke(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return fs(this, "includes", e) }, indexOf(...e) { return fs(this, "indexOf", e) }, join(e) { return Ye(this).join(e) }, lastIndexOf(...e) { return fs(this, "lastIndexOf", e) }, map(e, t) { return ke(this, "map", e, t, void 0, arguments) }, pop() { return ft(this, "pop") }, push(...e) { return ft(this, "push", e) }, reduce(e, ...t) { return cn(this, "reduce", e, t) }, reduceRight(e, ...t) { return cn(this, "reduceRight", e, t) }, shift() { return ft(this, "shift") }, some(e, t) { return ke(this, "some", e, t, void 0, arguments) }, splice(...e) { return ft(this, "splice", e) }, toReversed() { return Ye(this).toReversed() }, toSorted(e) { return Ye(this).toSorted(e) }, toSpliced(...e) { return Ye(this).toSpliced(...e) }, unshift(...e) { return ft(this, "unshift", e) }, values() { return cs(this, "values", Y) } }; function cs(e, t, s) { const n = Jt(e), i = n[t](); return n !== e && !de(e) && (i._next = i.next, i.next = () => { const r = i._next(); return r.value && (r.value = s(r.value)), r }), i } const rr = Array.prototype; function ke(e, t, s, n, i, r) { const o = Jt(e), c = o !== e && !de(e), u = o[t]; if (u !== rr[t]) { const p = u.apply(e, r); return c ? Y(p) : p } let h = s; o !== e && (c ? h = function (p, x) { return s.call(this, Y(p), x, e) } : s.length > 2 && (h = function (p, x) { return s.call(this, p, x, e) })); const a = u.call(o, h, n); return c && i ? i(a) : a } function cn(e, t, s, n) { const i = Jt(e); let r = s; return i !== e && (de(e) ? s.length > 3 && (r = function (o, c, u) { return s.call(this, o, c, u, e) }) : r = function (o, c, u) { return s.call(this, o, Y(c), u, e) }), i[t](r, ...n) } function fs(e, t, s) { const n = F(e); X(n, "iterate", yt); const i = n[t](...s); return (i === -1 || i === !1) && Bs(s[0]) ? (s[0] = F(s[0]), n[t](...s)) : i } function ft(e, t, s = []) { De(), Fs(); const n = F(e)[t].apply(e, s); return zs(), He(), n } const or = Os("__proto__,__v_isRef,__isVue"), Xn = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(ze)); function lr(e) { ze(e) || (e = String(e)); const t = F(this); return X(t, "has", e), t.hasOwnProperty(e) } class ei { constructor(t = !1, s = !1) { this._isReadonly = t, this._isShallow = s } get(t, s, n) { const i = this._isReadonly, r = this._isShallow; if (s === "__v_isReactive") return !i; if (s === "__v_isReadonly") return i; if (s === "__v_isShallow") return r; if (s === "__v_raw") return n === (i ? r ? vr : ii : r ? ni : si).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(n) ? t : void 0; const o = T(t); if (!i) { let u; if (o && (u = ir[s])) return u; if (s === "hasOwnProperty") return lr } const c = Reflect.get(t, s, Z(t) ? t : n); return (ze(s) ? Xn.has(s) : or(s)) || (i || X(t, "get", s), r) ? c : Z(c) ? o && Ms(s) ? c : c.value : W(c) ? i ? ri(c) : Ls(c) : c } } class ti extends ei { constructor(t = !1) { super(!1, t) } set(t, s, n, i) { let r = t[s]; if (!this._isShallow) { const u = qe(r); if (!de(n) && !qe(n) && (r = F(r), n = F(n)), !T(t) && Z(r) && !Z(n)) return u ? !1 : (r.value = n, !0) } const o = T(t) && Ms(s) ? Number(s) < t.length : R(t, s), c = Reflect.set(t, s, n, Z(t) ? t : i); return t === F(i) && (o ? Fe(n, r) && Ae(t, "set", s, n) : Ae(t, "add", s, n)), c } deleteProperty(t, s) { const n = R(t, s); t[s]; const i = Reflect.deleteProperty(t, s); return i && n && Ae(t, "delete", s, void 0), i } has(t, s) { const n = Reflect.has(t, s); return (!ze(s) || !Xn.has(s)) && X(t, "has", s), n } ownKeys(t) { return X(t, "iterate", T(t) ? "length" : Ke), Reflect.ownKeys(t) } } class cr extends ei { constructor(t = !1) { super(!0, t) } set(t, s) { return !0 } deleteProperty(t, s) { return !0 } } const fr = new ti, ur = new cr, ar = new ti(!0); const Ns = e => e, Yt = e => Reflect.getPrototypeOf(e); function Ot(e, t, s = !1, n = !1) { e = e.__v_raw; const i = F(e), r = F(t); s || (Fe(t, r) && X(i, "get", t), X(i, "get", r)); const { has: o } = Yt(i), c = n ? Ns : s ? Ws : Y; if (o.call(i, t)) return c(e.get(t)); if (o.call(i, r)) return c(e.get(r)); e !== i && e.get(t) } function It(e, t = !1) { const s = this.__v_raw, n = F(s), i = F(e); return t || (Fe(e, i) && X(n, "has", e), X(n, "has", i)), e === i ? s.has(e) : s.has(e) || s.has(i) } function Pt(e, t = !1) { return e = e.__v_raw, !t && X(F(e), "iterate", Ke), Reflect.get(e, "size", e) } function fn(e, t = !1) { !t && !de(e) && !qe(e) && (e = F(e)); const s = F(this); return Yt(s).has.call(s, e) || (s.add(e), Ae(s, "add", e, e)), this } function un(e, t, s = !1) { !s && !de(t) && !qe(t) && (t = F(t)); const n = F(this), { has: i, get: r } = Yt(n); let o = i.call(n, e); o || (e = F(e), o = i.call(n, e)); const c = r.call(n, e); return n.set(e, t), o ? Fe(t, c) && Ae(n, "set", e, t) : Ae(n, "add", e, t), this } function an(e) { const t = F(this), { has: s, get: n } = Yt(t); let i = s.call(t, e); i || (e = F(e), i = s.call(t, e)), n && n.call(t, e); const r = t.delete(e); return i && Ae(t, "delete", e, void 0), r } function dn() { const e = F(this), t = e.size !== 0, s = e.clear(); return t && Ae(e, "clear", void 0, void 0), s } function Mt(e, t) { return function (n, i) { const r = this, o = r.__v_raw, c = F(o), u = t ? Ns : e ? Ws : Y; return !e && X(c, "iterate", Ke), o.forEach((h, a) => n.call(i, u(h), u(a), r)) } } function Rt(e, t, s) { return function (...n) { const i = this.__v_raw, r = F(i), o = Xe(r), c = e === "entries" || e === Symbol.iterator && o, u = e === "keys" && o, h = i[e](...n), a = s ? Ns : t ? Ws : Y; return !t && X(r, "iterate", u ? xs : Ke), { next() { const { value: p, done: x } = h.next(); return x ? { value: p, done: x } : { value: c ? [a(p[0]), a(p[1])] : a(p), done: x } }, [Symbol.iterator]() { return this } } } } function Ie(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function dr() { const e = { get(r) { return Ot(this, r) }, get size() { return Pt(this) }, has: It, add: fn, set: un, delete: an, clear: dn, forEach: Mt(!1, !1) }, t = { get(r) { return Ot(this, r, !1, !0) }, get size() { return Pt(this) }, has: It, add(r) { return fn.call(this, r, !0) }, set(r, o) { return un.call(this, r, o, !0) }, delete: an, clear: dn, forEach: Mt(!1, !0) }, s = { get(r) { return Ot(this, r, !0) }, get size() { return Pt(this, !0) }, has(r) { return It.call(this, r, !0) }, add: Ie("add"), set: Ie("set"), delete: Ie("delete"), clear: Ie("clear"), forEach: Mt(!0, !1) }, n = { get(r) { return Ot(this, r, !0, !0) }, get size() { return Pt(this, !0) }, has(r) { return It.call(this, r, !0) }, add: Ie("add"), set: Ie("set"), delete: Ie("delete"), clear: Ie("clear"), forEach: Mt(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(r => { e[r] = Rt(r, !1, !1), s[r] = Rt(r, !0, !1), t[r] = Rt(r, !1, !0), n[r] = Rt(r, !0, !0) }), [e, s, t, n] } const [hr, pr, gr, mr] = dr(); function $s(e, t) { const s = t ? e ? mr : gr : e ? pr : hr; return (n, i, r) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? n : Reflect.get(R(s, i) && i in n ? s : n, i, r) } const br = { get: $s(!1, !1) }, yr = { get: $s(!1, !0) }, _r = { get: $s(!0, !1) }; const si = new WeakMap, ni = new WeakMap, ii = new WeakMap, vr = new WeakMap; function xr(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function wr(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : xr(Wi(e)) } function Ls(e) { return qe(e) ? e : Us(e, !1, fr, br, si) } function Sr(e) { return Us(e, !1, ar, yr, ni) } function ri(e) { return Us(e, !0, ur, _r, ii) } function Us(e, t, s, n, i) { if (!W(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const r = i.get(e); if (r) return r; const o = wr(e); if (o === 0) return e; const c = new Proxy(e, o === 2 ? n : s); return i.set(e, c), c } function et(e) { return qe(e) ? et(e.__v_raw) : !!(e && e.__v_isReactive) } function qe(e) { return !!(e && e.__v_isReadonly) } function de(e) { return !!(e && e.__v_isShallow) } function Bs(e) { return e ? !!e.__v_raw : !1 } function F(e) { const t = e && e.__v_raw; return t ? F(t) : e } function jr(e) { return !R(e, "__v_skip") && Object.isExtensible(e) && Ln(e, "__v_skip", !0), e } const Y = e => W(e) ? Ls(e) : e, Ws = e => W(e) ? ri(e) : e; function Z(e) { return e ? e.__v_isRef === !0 : !1 } function us(e) { return kr(e, !1) } function kr(e, t) { return Z(e) ? e : new Cr(e, t) } class Cr { constructor(t, s) { this.dep = new Hs, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? t : F(t), this._value = s ? t : Y(t), this.__v_isShallow = s } get value() { return this.dep.track(), this._value } set value(t) { const s = this._rawValue, n = this.__v_isShallow || de(t) || qe(t); t = n ? t : F(t), Fe(t, s) && (this._rawValue = t, this._value = n ? t : Y(t), this.dep.trigger()) } } function oi(e) { return Z(e) ? e.value : e } const Ar = { get: (e, t, s) => t === "__v_raw" ? e : oi(Reflect.get(e, t, s)), set: (e, t, s, n) => { const i = e[t]; return Z(i) && !Z(s) ? (i.value = s, !0) : Reflect.set(e, t, s, n) } }; function li(e) { return et(e) ? e : new Proxy(e, Ar) } class Tr { constructor(t, s, n) { this.fn = t, this.setter = s, this._value = void 0, this.dep = new Hs(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = bt - 1, this.effect = this, this.__v_isReadonly = !s, this.isSSR = n } notify() { this.flags |= 16, H !== this && this.dep.notify() } get value() { const t = this.dep.track(); return Yn(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function Er(e, t, s = !1) { let n, i; return O(e) ? n = e : (n = e.get, i = e.set), new Tr(n, i, s) } const Ft = {}, $t = new WeakMap; let We; function Or(e, t = !1, s = We) { if (s) { let n = $t.get(s); n || $t.set(s, n = []), n.push(e) } } function Ir(e, t, s = U) { const { immediate: n, deep: i, once: r, scheduler: o, augmentJob: c, call: u } = s, h = C => i ? C : de(C) || i === !1 || i === 0 ? Re(C, 1) : Re(C); let a, p, x, E, M = !1, P = !1; if (Z(e) ? (p = () => e.value, M = de(e)) : et(e) ? (p = () => h(e), M = !0) : T(e) ? (P = !0, M = e.some(C => et(C) || de(C)), p = () => e.map(C => { if (Z(C)) return C.value; if (et(C)) return h(C); if (O(C)) return u ? u(C, 2) : C() })) : O(e) ? t ? p = u ? () => u(e, 2) : e : p = () => { if (x) { De(); try { x() } finally { He() } } const C = We; We = a; try { return u ? u(e, 3, [E]) : e(E) } finally { We = C } } : p = Se, t && i) { const C = p, q = i === !0 ? 1 / 0 : i; p = () => Re(C(), q) } const ee = tr(), D = () => { a.stop(), ee && Ps(ee.effects, a) }; if (r) if (t) { const C = t; t = (...q) => { C(...q), D() } } else { const C = p; p = () => { C(), D() } } let K = P ? new Array(e.length).fill(Ft) : Ft; const V = C => { if (!(!(a.flags & 1) || !a.dirty && !C)) if (t) { const q = a.run(); if (i || M || (P ? q.some((Ee, me) => Fe(Ee, K[me])) : Fe(q, K))) { x && x(); const Ee = We; We = a; try { const me = [q, K === Ft ? void 0 : P && K[0] === Ft ? [] : K, E]; u ? u(t, 3, me) : t(...me), K = q } finally { We = Ee } } } else a.run() }; return c && c(V), a = new Vn(p), a.scheduler = o ? () => o(V, !1) : V, E = C => Or(C, !1, a), x = a.onStop = () => { const C = $t.get(a); if (C) { if (u) u(C, 4); else for (const q of C) q(); $t.delete(a) } }, t ? n ? V(!0) : K = a.run() : o ? o(V.bind(null, !0), !0) : a.run(), D.pause = a.pause.bind(a), D.resume = a.resume.bind(a), D.stop = D, D } function Re(e, t = 1 / 0, s) { if (t <= 0 || !W(e) || e.__v_skip || (s = s || new Set, s.has(e))) return e; if (s.add(e), t--, Z(e)) Re(e.value, t, s); else if (T(e)) for (let n = 0; n < e.length; n++)Re(e[n], t, s); else if (zn(e) || Xe(e)) e.forEach(n => { Re(n, t, s) }); else if (Nn(e)) { for (const n in e) Re(e[n], t, s); for (const n of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, n) && Re(e[n], t, s) } return e }/**
* @vue/runtime-core v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function St(e, t, s, n) { try { return n ? e(...n) : e() } catch (i) { Zt(i, t, s) } } function je(e, t, s, n) { if (O(e)) { const i = St(e, t, s, n); return i && Dn(i) && i.catch(r => { Zt(r, t, s) }), i } if (T(e)) { const i = []; for (let r = 0; r < e.length; r++)i.push(je(e[r], t, s, n)); return i } } function Zt(e, t, s, n = !0) { const i = t ? t.vnode : null, { errorHandler: r, throwUnhandledErrorInProduction: o } = t && t.appContext.config || U; if (t) { let c = t.parent; const u = t.proxy, h = `https://vuejs.org/error-reference/#runtime-${s}`; for (; c;) { const a = c.ec; if (a) { for (let p = 0; p < a.length; p++)if (a[p](e, u, h) === !1) return } c = c.parent } if (r) { De(), St(r, null, 10, [e, u, h]), He(); return } } Pr(e, s, i, n, o) } function Pr(e, t, s, n = !0, i = !1) { if (i) throw e; console.error(e) } let _t = !1, ws = !1; const ne = []; let ve = 0; const tt = []; let Pe = null, Ze = 0; const ci = Promise.resolve(); let Ks = null; function Mr(e) { const t = Ks || ci; return e ? t.then(this ? e.bind(this) : e) : t } function Rr(e) { let t = _t ? ve + 1 : 0, s = ne.length; for (; t < s;) { const n = t + s >>> 1, i = ne[n], r = vt(i); r < e || r === e && i.flags & 2 ? t = n + 1 : s = n } return t } function Vs(e) { if (!(e.flags & 1)) { const t = vt(e), s = ne[ne.length - 1]; !s || !(e.flags & 2) && t >= vt(s) ? ne.push(e) : ne.splice(Rr(t), 0, e), e.flags |= 1, fi() } } function fi() { !_t && !ws && (ws = !0, Ks = ci.then(ai)) } function Fr(e) { T(e) ? tt.push(...e) : Pe && e.id === -1 ? Pe.splice(Ze + 1, 0, e) : e.flags & 1 || (tt.push(e), e.flags |= 1), fi() } function hn(e, t, s = _t ? ve + 1 : 0) { for (; s < ne.length; s++) { const n = ne[s]; if (n && n.flags & 2) { if (e && n.id !== e.uid) continue; ne.splice(s, 1), s--, n.flags & 4 && (n.flags &= -2), n(), n.flags &= -2 } } } function ui(e) { if (tt.length) { const t = [...new Set(tt)].sort((s, n) => vt(s) - vt(n)); if (tt.length = 0, Pe) { Pe.push(...t); return } for (Pe = t, Ze = 0; Ze < Pe.length; Ze++) { const s = Pe[Ze]; s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2 } Pe = null, Ze = 0 } } const vt = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function ai(e) { ws = !1, _t = !0; try { for (ve = 0; ve < ne.length; ve++) { const t = ne[ve]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), St(t, t.i, t.i ? 15 : 14), t.flags &= -2) } } finally { for (; ve < ne.length; ve++) { const t = ne[ve]; t && (t.flags &= -2) } ve = 0, ne.length = 0, ui(), _t = !1, Ks = null, (ne.length || tt.length) && ai() } } let we = null, di = null; function Lt(e) { const t = we; return we = e, di = e && e.type.__scopeId || null, t } function zr(e, t = we, s) { if (!t || e._n) return e; const n = (...i) => { n._d && xn(-1); const r = Lt(t); let o; try { o = e(...i) } finally { Lt(r), n._d && xn(1) } return o }; return n._n = !0, n._c = !0, n._d = !0, n } function Ue(e, t, s, n) { const i = e.dirs, r = t && t.dirs; for (let o = 0; o < i.length; o++) { const c = i[o]; r && (c.oldValue = r[o].value); let u = c.dir[n]; u && (De(), je(u, s, 8, [e.el, c, e, t]), He()) } } const Dr = Symbol("_vte"), Hr = e => e.__isTeleport; function Gs(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Gs(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function hi(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function Ss(e, t, s, n, i = !1) { if (T(e)) { e.forEach((M, P) => Ss(M, t && (T(t) ? t[P] : t), s, n, i)); return } if (pt(n) && !i) return; const r = n.shapeFlag & 4 ? Zs(n.component) : n.el, o = i ? null : r, { i: c, r: u } = e, h = t && t.r, a = c.refs === U ? c.refs = {} : c.refs, p = c.setupState, x = F(p), E = p === U ? () => !1 : M => R(x, M); if (h != null && h !== u && (G(h) ? (a[h] = null, E(h) && (p[h] = null)) : Z(h) && (h.value = null)), O(u)) St(u, c, 12, [o, a]); else { const M = G(u), P = Z(u); if (M || P) { const ee = () => { if (e.f) { const D = M ? E(u) ? p[u] : a[u] : u.value; i ? T(D) && Ps(D, r) : T(D) ? D.includes(r) || D.push(r) : M ? (a[u] = [r], E(u) && (p[u] = a[u])) : (u.value = [r], e.k && (a[e.k] = u.value)) } else M ? (a[u] = o, E(u) && (p[u] = o)) : P && (u.value = o, e.k && (a[e.k] = o)) }; o ? (ee.id = -1, ce(ee, s)) : ee() } } } const pt = e => !!e.type.__asyncLoader, pi = e => e.type.__isKeepAlive; function Nr(e, t) { gi(e, "a", t) } function $r(e, t) { gi(e, "da", t) } function gi(e, t, s = ie) { const n = e.__wdc || (e.__wdc = () => { let i = s; for (; i;) { if (i.isDeactivated) return; i = i.parent } return e() }); if (Qt(t, n, s), s) { let i = s.parent; for (; i && i.parent;)pi(i.parent.vnode) && Lr(n, t, s, i), i = i.parent } } function Lr(e, t, s, n) { const i = Qt(t, e, n, !0); mi(() => { Ps(n[t], i) }, s) } function Qt(e, t, s = ie, n = !1) { if (s) { const i = s[e] || (s[e] = []), r = t.__weh || (t.__weh = (...o) => { De(); const c = jt(s), u = je(t, s, e, o); return c(), He(), u }); return n ? i.unshift(r) : i.push(r), r } } const Te = e => (t, s = ie) => { (!ts || e === "sp") && Qt(e, (...n) => t(...n), s) }, Ur = Te("bm"), Br = Te("m"), Wr = Te("bu"), Kr = Te("u"), Vr = Te("bum"), mi = Te("um"), Gr = Te("sp"), qr = Te("rtg"), Jr = Te("rtc"); function Yr(e, t = ie) { Qt("ec", e, t) } const Zr = Symbol.for("v-ndc"); function bi(e, t, s, n) { let i; const r = s, o = T(e); if (o || G(e)) { const c = o && et(e); let u = !1; c && (u = !de(e), e = Jt(e)), i = new Array(e.length); for (let h = 0, a = e.length; h < a; h++)i[h] = t(u ? Y(e[h]) : e[h], h, void 0, r) } else if (typeof e == "number") { i = new Array(e); for (let c = 0; c < e; c++)i[c] = t(c + 1, c, void 0, r) } else if (W(e)) if (e[Symbol.iterator]) i = Array.from(e, (c, u) => t(c, u, void 0, r)); else { const c = Object.keys(e); i = new Array(c.length); for (let u = 0, h = c.length; u < h; u++) { const a = c[u]; i[u] = t(e[a], a, u, r) } } else i = []; return i } const js = e => e ? Di(e) ? Zs(e) : js(e.parent) : null, gt = Q(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => js(e.parent), $root: e => js(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => qs(e), $forceUpdate: e => e.f || (e.f = () => { Vs(e.update) }), $nextTick: e => e.n || (e.n = Mr.bind(e.proxy)), $watch: e => vo.bind(e) }), as = (e, t) => e !== U && !e.__isScriptSetup && R(e, t), Qr = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: s, setupState: n, data: i, props: r, accessCache: o, type: c, appContext: u } = e; let h; if (t[0] !== "$") { const E = o[t]; if (E !== void 0) switch (E) { case 1: return n[t]; case 2: return i[t]; case 4: return s[t]; case 3: return r[t] } else { if (as(n, t)) return o[t] = 1, n[t]; if (i !== U && R(i, t)) return o[t] = 2, i[t]; if ((h = e.propsOptions[0]) && R(h, t)) return o[t] = 3, r[t]; if (s !== U && R(s, t)) return o[t] = 4, s[t]; ks && (o[t] = 0) } } const a = gt[t]; let p, x; if (a) return t === "$attrs" && X(e.attrs, "get", ""), a(e); if ((p = c.__cssModules) && (p = p[t])) return p; if (s !== U && R(s, t)) return o[t] = 4, s[t]; if (x = u.config.globalProperties, R(x, t)) return x[t] }, set({ _: e }, t, s) { const { data: n, setupState: i, ctx: r } = e; return as(i, t) ? (i[t] = s, !0) : n !== U && R(n, t) ? (n[t] = s, !0) : R(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = s, !0) }, has({ _: { data: e, setupState: t, accessCache: s, ctx: n, appContext: i, propsOptions: r } }, o) { let c; return !!s[o] || e !== U && R(e, o) || as(t, o) || (c = r[0]) && R(c, o) || R(n, o) || R(gt, o) || R(i.config.globalProperties, o) }, defineProperty(e, t, s) { return s.get != null ? e._.accessCache[t] = 0 : R(s, "value") && this.set(e, t, s.value, null), Reflect.defineProperty(e, t, s) } }; function pn(e) { return T(e) ? e.reduce((t, s) => (t[s] = null, t), {}) : e } let ks = !0; function Xr(e) { const t = qs(e), s = e.proxy, n = e.ctx; ks = !1, t.beforeCreate && gn(t.beforeCreate, e, "bc"); const { data: i, computed: r, methods: o, watch: c, provide: u, inject: h, created: a, beforeMount: p, mounted: x, beforeUpdate: E, updated: M, activated: P, deactivated: ee, beforeDestroy: D, beforeUnmount: K, destroyed: V, unmounted: C, render: q, renderTracked: Ee, renderTriggered: me, errorCaptured: Oe, serverPrefetch: kt, expose: Ne, inheritAttrs: rt, components: Ct, directives: At, filters: ss } = t; if (h && eo(h, n, null), o) for (const B in o) { const $ = o[B]; O($) && (n[B] = $.bind(s)) } if (i) { const B = i.call(s, s); W(B) && (e.data = Ls(B)) } if (ks = !0, r) for (const B in r) { const $ = r[B], $e = O($) ? $.bind(s, s) : O($.get) ? $.get.bind(s, s) : Se, Tt = !O($) && O($.set) ? $.set.bind(s) : Se, Le = Uo({ get: $e, set: Tt }); Object.defineProperty(n, B, { enumerable: !0, configurable: !0, get: () => Le.value, set: be => Le.value = be }) } if (c) for (const B in c) yi(c[B], n, s, B); if (u) { const B = O(u) ? u.call(s) : u; Reflect.ownKeys(B).forEach($ => { oo($, B[$]) }) } a && gn(a, e, "c"); function te(B, $) { T($) ? $.forEach($e => B($e.bind(s))) : $ && B($.bind(s)) } if (te(Ur, p), te(Br, x), te(Wr, E), te(Kr, M), te(Nr, P), te($r, ee), te(Yr, Oe), te(Jr, Ee), te(qr, me), te(Vr, K), te(mi, C), te(Gr, kt), T(Ne)) if (Ne.length) { const B = e.exposed || (e.exposed = {}); Ne.forEach($ => { Object.defineProperty(B, $, { get: () => s[$], set: $e => s[$] = $e }) }) } else e.exposed || (e.exposed = {}); q && e.render === Se && (e.render = q), rt != null && (e.inheritAttrs = rt), Ct && (e.components = Ct), At && (e.directives = At), kt && hi(e) } function eo(e, t, s = Se) { T(e) && (e = Cs(e)); for (const n in e) { const i = e[n]; let r; W(i) ? "default" in i ? r = Dt(i.from || n, i.default, !0) : r = Dt(i.from || n) : r = Dt(i), Z(r) ? Object.defineProperty(t, n, { enumerable: !0, configurable: !0, get: () => r.value, set: o => r.value = o }) : t[n] = r } } function gn(e, t, s) { je(T(e) ? e.map(n => n.bind(t.proxy)) : e.bind(t.proxy), t, s) } function yi(e, t, s, n) { let i = n.includes(".") ? Pi(s, n) : () => s[n]; if (G(e)) { const r = t[e]; O(r) && hs(i, r) } else if (O(e)) hs(i, e.bind(s)); else if (W(e)) if (T(e)) e.forEach(r => yi(r, t, s, n)); else { const r = O(e.handler) ? e.handler.bind(s) : t[e.handler]; O(r) && hs(i, r, e) } } function qs(e) { const t = e.type, { mixins: s, extends: n } = t, { mixins: i, optionsCache: r, config: { optionMergeStrategies: o } } = e.appContext, c = r.get(t); let u; return c ? u = c : !i.length && !s && !n ? u = t : (u = {}, i.length && i.forEach(h => Ut(u, h, o, !0)), Ut(u, t, o)), W(t) && r.set(t, u), u } function Ut(e, t, s, n = !1) { const { mixins: i, extends: r } = t; r && Ut(e, r, s, !0), i && i.forEach(o => Ut(e, o, s, !0)); for (const o in t) if (!(n && o === "expose")) { const c = to[o] || s && s[o]; e[o] = c ? c(e[o], t[o]) : t[o] } return e } const to = { data: mn, props: bn, emits: bn, methods: at, computed: at, beforeCreate: se, created: se, beforeMount: se, mounted: se, beforeUpdate: se, updated: se, beforeDestroy: se, beforeUnmount: se, destroyed: se, unmounted: se, activated: se, deactivated: se, errorCaptured: se, serverPrefetch: se, components: at, directives: at, watch: no, provide: mn, inject: so }; function mn(e, t) { return t ? e ? function () { return Q(O(e) ? e.call(this, this) : e, O(t) ? t.call(this, this) : t) } : t : e } function so(e, t) { return at(Cs(e), Cs(t)) } function Cs(e) { if (T(e)) { const t = {}; for (let s = 0; s < e.length; s++)t[e[s]] = e[s]; return t } return e } function se(e, t) { return e ? [...new Set([].concat(e, t))] : t } function at(e, t) { return e ? Q(Object.create(null), e, t) : t } function bn(e, t) { return e ? T(e) && T(t) ? [...new Set([...e, ...t])] : Q(Object.create(null), pn(e), pn(t ?? {})) : t } function no(e, t) { if (!e) return t; if (!t) return e; const s = Q(Object.create(null), e); for (const n in t) s[n] = se(e[n], t[n]); return s } function _i() { return { app: null, config: { isNativeTag: Ui, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let io = 0; function ro(e, t) { return function (n, i = null) { O(n) || (n = Q({}, n)), i != null && !W(i) && (i = null); const r = _i(), o = new WeakSet, c = []; let u = !1; const h = r.app = { _uid: io++, _component: n, _props: i, _container: null, _context: r, _instance: null, version: Bo, get config() { return r.config }, set config(a) { }, use(a, ...p) { return o.has(a) || (a && O(a.install) ? (o.add(a), a.install(h, ...p)) : O(a) && (o.add(a), a(h, ...p))), h }, mixin(a) { return r.mixins.includes(a) || r.mixins.push(a), h }, component(a, p) { return p ? (r.components[a] = p, h) : r.components[a] }, directive(a, p) { return p ? (r.directives[a] = p, h) : r.directives[a] }, mount(a, p, x) { if (!u) { const E = h._ceVNode || ge(n, i); return E.appContext = r, x === !0 ? x = "svg" : x === !1 && (x = void 0), p && t ? t(E, a) : e(E, a, x), u = !0, h._container = a, a.__vue_app__ = h, Zs(E.component) } }, onUnmount(a) { c.push(a) }, unmount() { u && (je(c, h._instance, 16), e(null, h._container), delete h._container.__vue_app__) }, provide(a, p) { return r.provides[a] = p, h }, runWithContext(a) { const p = st; st = h; try { return a() } finally { st = p } } }; return h } } let st = null; function oo(e, t) { if (ie) { let s = ie.provides; const n = ie.parent && ie.parent.provides; n === s && (s = ie.provides = Object.create(n)), s[e] = t } } function Dt(e, t, s = !1) { const n = ie || we; if (n || st) { const i = st ? st._context.provides : n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0; if (i && e in i) return i[e]; if (arguments.length > 1) return s && O(t) ? t.call(n && n.proxy) : t } } const vi = {}, xi = () => Object.create(vi), wi = e => Object.getPrototypeOf(e) === vi; function lo(e, t, s, n = !1) { const i = {}, r = xi(); e.propsDefaults = Object.create(null), Si(e, t, i, r); for (const o in e.propsOptions[0]) o in i || (i[o] = void 0); s ? e.props = n ? i : Sr(i) : e.type.props ? e.props = i : e.props = r, e.attrs = r } function co(e, t, s, n) { const { props: i, attrs: r, vnode: { patchFlag: o } } = e, c = F(i), [u] = e.propsOptions; let h = !1; if ((n || o > 0) && !(o & 16)) { if (o & 8) { const a = e.vnode.dynamicProps; for (let p = 0; p < a.length; p++) { let x = a[p]; if (Xt(e.emitsOptions, x)) continue; const E = t[x]; if (u) if (R(r, x)) E !== r[x] && (r[x] = E, h = !0); else { const M = Ge(x); i[M] = As(u, c, M, E, e, !1) } else E !== r[x] && (r[x] = E, h = !0) } } } else { Si(e, t, i, r) && (h = !0); let a; for (const p in c) (!t || !R(t, p) && ((a = Je(p)) === p || !R(t, a))) && (u ? s && (s[p] !== void 0 || s[a] !== void 0) && (i[p] = As(u, c, p, void 0, e, !0)) : delete i[p]); if (r !== c) for (const p in r) (!t || !R(t, p)) && (delete r[p], h = !0) } h && Ae(e.attrs, "set", "") } function Si(e, t, s, n) { const [i, r] = e.propsOptions; let o = !1, c; if (t) for (let u in t) { if (dt(u)) continue; const h = t[u]; let a; i && R(i, a = Ge(u)) ? !r || !r.includes(a) ? s[a] = h : (c || (c = {}))[a] = h : Xt(e.emitsOptions, u) || (!(u in n) || h !== n[u]) && (n[u] = h, o = !0) } if (r) { const u = F(s), h = c || U; for (let a = 0; a < r.length; a++) { const p = r[a]; s[p] = As(i, u, p, h[p], e, !R(h, p)) } } return o } function As(e, t, s, n, i, r) { const o = e[s]; if (o != null) { const c = R(o, "default"); if (c && n === void 0) { const u = o.default; if (o.type !== Function && !o.skipFactory && O(u)) { const { propsDefaults: h } = i; if (s in h) n = h[s]; else { const a = jt(i); n = h[s] = u.call(null, t), a() } } else n = u; i.ce && i.ce._setProp(s, n) } o[0] && (r && !c ? n = !1 : o[1] && (n === "" || n === Je(s)) && (n = !0)) } return n } const fo = new WeakMap; function ji(e, t, s = !1) { const n = s ? fo : t.propsCache, i = n.get(e); if (i) return i; const r = e.props, o = {}, c = []; let u = !1; if (!O(e)) { const a = p => { u = !0; const [x, E] = ji(p, t, !0); Q(o, x), E && c.push(...E) }; !s && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!r && !u) return W(e) && n.set(e, Qe), Qe; if (T(r)) for (let a = 0; a < r.length; a++) { const p = Ge(r[a]); yn(p) && (o[p] = U) } else if (r) for (const a in r) { const p = Ge(a); if (yn(p)) { const x = r[a], E = o[p] = T(x) || O(x) ? { type: x } : Q({}, x), M = E.type; let P = !1, ee = !0; if (T(M)) for (let D = 0; D < M.length; ++D) { const K = M[D], V = O(K) && K.name; if (V === "Boolean") { P = !0; break } else V === "String" && (ee = !1) } else P = O(M) && M.name === "Boolean"; E[0] = P, E[1] = ee, (P || R(E, "default")) && c.push(p) } } const h = [o, c]; return W(e) && n.set(e, h), h } function yn(e) { return e[0] !== "$" && !dt(e) } const ki = e => e[0] === "_" || e === "$stable", Js = e => T(e) ? e.map(xe) : [xe(e)], uo = (e, t, s) => { if (t._n) return t; const n = zr((...i) => Js(t(...i)), s); return n._c = !1, n }, Ci = (e, t, s) => { const n = e._ctx; for (const i in e) { if (ki(i)) continue; const r = e[i]; if (O(r)) t[i] = uo(i, r, n); else if (r != null) { const o = Js(r); t[i] = () => o } } }, Ai = (e, t) => { const s = Js(t); e.slots.default = () => s }, Ti = (e, t, s) => { for (const n in t) (s || n !== "_") && (e[n] = t[n]) }, ao = (e, t, s) => { const n = e.slots = xi(); if (e.vnode.shapeFlag & 32) { const i = t._; i ? (Ti(n, t, s), s && Ln(n, "_", i, !0)) : Ci(t, n) } else t && Ai(e, t) }, ho = (e, t, s) => { const { vnode: n, slots: i } = e; let r = !0, o = U; if (n.shapeFlag & 32) { const c = t._; c ? s && c === 1 ? r = !1 : Ti(i, t, s) : (r = !t.$stable, Ci(t, i)), o = t } else t && (Ai(e, t), o = { default: 1 }); if (r) for (const c in i) !ki(c) && o[c] == null && delete i[c] }, ce = Ao; function po(e) { return go(e) } function go(e, t) { const s = Un(); s.__VUE__ = !0; const { insert: n, remove: i, patchProp: r, createElement: o, createText: c, createComment: u, setText: h, setElementText: a, parentNode: p, nextSibling: x, setScopeId: E = Se, insertStaticContent: M } = e, P = (l, f, d, b = null, g = null, m = null, w = void 0, v = null, _ = !!f.dynamicChildren) => { if (l === f) return; l && !ut(l, f) && (b = Et(l), be(l, g, m, !0), l = null), f.patchFlag === -2 && (_ = !1, f.dynamicChildren = null); const { type: y, ref: k, shapeFlag: S } = f; switch (y) { case es: ee(l, f, d, b); break; case xt: D(l, f, d, b); break; case gs: l == null && K(f, d, b, w); break; case ae: Ct(l, f, d, b, g, m, w, v, _); break; default: S & 1 ? q(l, f, d, b, g, m, w, v, _) : S & 6 ? At(l, f, d, b, g, m, w, v, _) : (S & 64 || S & 128) && y.process(l, f, d, b, g, m, w, v, _, lt) }k != null && g && Ss(k, l && l.ref, m, f || l, !f) }, ee = (l, f, d, b) => { if (l == null) n(f.el = c(f.children), d, b); else { const g = f.el = l.el; f.children !== l.children && h(g, f.children) } }, D = (l, f, d, b) => { l == null ? n(f.el = u(f.children || ""), d, b) : f.el = l.el }, K = (l, f, d, b) => { [l.el, l.anchor] = M(l.children, f, d, b, l.el, l.anchor) }, V = ({ el: l, anchor: f }, d, b) => { let g; for (; l && l !== f;)g = x(l), n(l, d, b), l = g; n(f, d, b) }, C = ({ el: l, anchor: f }) => { let d; for (; l && l !== f;)d = x(l), i(l), l = d; i(f) }, q = (l, f, d, b, g, m, w, v, _) => { f.type === "svg" ? w = "svg" : f.type === "math" && (w = "mathml"), l == null ? Ee(f, d, b, g, m, w, v, _) : kt(l, f, g, m, w, v, _) }, Ee = (l, f, d, b, g, m, w, v) => { let _, y; const { props: k, shapeFlag: S, transition: j, dirs: A } = l; if (_ = l.el = o(l.type, m, k && k.is, k), S & 8 ? a(_, l.children) : S & 16 && Oe(l.children, _, null, b, g, ds(l, m), w, v), A && Ue(l, null, b, "created"), me(_, l, l.scopeId, w, b), k) { for (const L in k) L !== "value" && !dt(L) && r(_, L, null, k[L], m, b); "value" in k && r(_, "value", null, k.value, m), (y = k.onVnodeBeforeMount) && _e(y, b, l) } A && Ue(l, null, b, "beforeMount"); const I = mo(g, j); I && j.beforeEnter(_), n(_, f, d), ((y = k && k.onVnodeMounted) || I || A) && ce(() => { y && _e(y, b, l), I && j.enter(_), A && Ue(l, null, b, "mounted") }, g) }, me = (l, f, d, b, g) => { if (d && E(l, d), b) for (let m = 0; m < b.length; m++)E(l, b[m]); if (g) { let m = g.subTree; if (f === m || Ri(m.type) && (m.ssContent === f || m.ssFallback === f)) { const w = g.vnode; me(l, w, w.scopeId, w.slotScopeIds, g.parent) } } }, Oe = (l, f, d, b, g, m, w, v, _ = 0) => { for (let y = _; y < l.length; y++) { const k = l[y] = v ? Me(l[y]) : xe(l[y]); P(null, k, f, d, b, g, m, w, v) } }, kt = (l, f, d, b, g, m, w) => { const v = f.el = l.el; let { patchFlag: _, dynamicChildren: y, dirs: k } = f; _ |= l.patchFlag & 16; const S = l.props || U, j = f.props || U; let A; if (d && Be(d, !1), (A = j.onVnodeBeforeUpdate) && _e(A, d, f, l), k && Ue(f, l, d, "beforeUpdate"), d && Be(d, !0), (S.innerHTML && j.innerHTML == null || S.textContent && j.textContent == null) && a(v, ""), y ? Ne(l.dynamicChildren, y, v, d, b, ds(f, g), m) : w || $(l, f, v, null, d, b, ds(f, g), m, !1), _ > 0) { if (_ & 16) rt(v, S, j, d, g); else if (_ & 2 && S.class !== j.class && r(v, "class", null, j.class, g), _ & 4 && r(v, "style", S.style, j.style, g), _ & 8) { const I = f.dynamicProps; for (let L = 0; L < I.length; L++) { const z = I[L], re = S[z], J = j[z]; (J !== re || z === "value") && r(v, z, re, J, g, d) } } _ & 1 && l.children !== f.children && a(v, f.children) } else !w && y == null && rt(v, S, j, d, g); ((A = j.onVnodeUpdated) || k) && ce(() => { A && _e(A, d, f, l), k && Ue(f, l, d, "updated") }, b) }, Ne = (l, f, d, b, g, m, w) => { for (let v = 0; v < f.length; v++) { const _ = l[v], y = f[v], k = _.el && (_.type === ae || !ut(_, y) || _.shapeFlag & 70) ? p(_.el) : d; P(_, y, k, null, b, g, m, w, !0) } }, rt = (l, f, d, b, g) => { if (f !== d) { if (f !== U) for (const m in f) !dt(m) && !(m in d) && r(l, m, f[m], null, g, b); for (const m in d) { if (dt(m)) continue; const w = d[m], v = f[m]; w !== v && m !== "value" && r(l, m, v, w, g, b) } "value" in d && r(l, "value", f.value, d.value, g) } }, Ct = (l, f, d, b, g, m, w, v, _) => { const y = f.el = l ? l.el : c(""), k = f.anchor = l ? l.anchor : c(""); let { patchFlag: S, dynamicChildren: j, slotScopeIds: A } = f; A && (v = v ? v.concat(A) : A), l == null ? (n(y, d, b), n(k, d, b), Oe(f.children || [], d, k, g, m, w, v, _)) : S > 0 && S & 64 && j && l.dynamicChildren ? (Ne(l.dynamicChildren, j, d, g, m, w, v), (f.key != null || g && f === g.subTree) && Ei(l, f, !0)) : $(l, f, d, k, g, m, w, v, _) }, At = (l, f, d, b, g, m, w, v, _) => { f.slotScopeIds = v, l == null ? f.shapeFlag & 512 ? g.ctx.activate(f, d, b, w, _) : ss(f, d, b, g, m, w, _) : Qs(l, f, _) }, ss = (l, f, d, b, g, m, w) => { const v = l.component = zo(l, b, g); if (pi(l) && (v.ctx.renderer = lt), Do(v, !1, w), v.asyncDep) { if (g && g.registerDep(v, te, w), !l.el) { const _ = v.subTree = ge(xt); D(null, _, f, d) } } else te(v, l, f, d, g, m, w) }, Qs = (l, f, d) => { const b = f.component = l.component; if (ko(l, f, d)) if (b.asyncDep && !b.asyncResolved) { B(b, f, d); return } else b.next = f, b.update(); else f.el = l.el, b.vnode = f }, te = (l, f, d, b, g, m, w) => { const v = () => { if (l.isMounted) { let { next: S, bu: j, u: A, parent: I, vnode: L } = l; { const oe = Oi(l); if (oe) { S && (S.el = L.el, B(l, S, w)), oe.asyncDep.then(() => { l.isUnmounted || v() }); return } } let z = S, re; Be(l, !1), S ? (S.el = L.el, B(l, S, w)) : S = L, j && rs(j), (re = S.props && S.props.onVnodeBeforeUpdate) && _e(re, I, S, L), Be(l, !0); const J = ps(l), he = l.subTree; l.subTree = J, P(he, J, p(he.el), Et(he), l, g, m), S.el = J.el, z === null && Co(l, J.el), A && ce(A, g), (re = S.props && S.props.onVnodeUpdated) && ce(() => _e(re, I, S, L), g) } else { let S; const { el: j, props: A } = f, { bm: I, m: L, parent: z, root: re, type: J } = l, he = pt(f); if (Be(l, !1), I && rs(I), !he && (S = A && A.onVnodeBeforeMount) && _e(S, z, f), Be(l, !0), j && sn) { const oe = () => { l.subTree = ps(l), sn(j, l.subTree, l, g, null) }; he && J.__asyncHydrate ? J.__asyncHydrate(j, l, oe) : oe() } else { re.ce && re.ce._injectChildStyle(J); const oe = l.subTree = ps(l); P(null, oe, d, b, l, g, m), f.el = oe.el } if (L && ce(L, g), !he && (S = A && A.onVnodeMounted)) { const oe = f; ce(() => _e(S, z, oe), g) } (f.shapeFlag & 256 || z && pt(z.vnode) && z.vnode.shapeFlag & 256) && l.a && ce(l.a, g), l.isMounted = !0, f = d = b = null } }; l.scope.on(); const _ = l.effect = new Vn(v); l.scope.off(); const y = l.update = _.run.bind(_), k = l.job = _.runIfDirty.bind(_); k.i = l, k.id = l.uid, _.scheduler = () => Vs(k), Be(l, !0), y() }, B = (l, f, d) => { f.component = l; const b = l.vnode.props; l.vnode = f, l.next = null, co(l, f.props, b, d), ho(l, f.children, d), De(), hn(l), He() }, $ = (l, f, d, b, g, m, w, v, _ = !1) => { const y = l && l.children, k = l ? l.shapeFlag : 0, S = f.children, { patchFlag: j, shapeFlag: A } = f; if (j > 0) { if (j & 128) { Tt(y, S, d, b, g, m, w, v, _); return } else if (j & 256) { $e(y, S, d, b, g, m, w, v, _); return } } A & 8 ? (k & 16 && ot(y, g, m), S !== y && a(d, S)) : k & 16 ? A & 16 ? Tt(y, S, d, b, g, m, w, v, _) : ot(y, g, m, !0) : (k & 8 && a(d, ""), A & 16 && Oe(S, d, b, g, m, w, v, _)) }, $e = (l, f, d, b, g, m, w, v, _) => { l = l || Qe, f = f || Qe; const y = l.length, k = f.length, S = Math.min(y, k); let j; for (j = 0; j < S; j++) { const A = f[j] = _ ? Me(f[j]) : xe(f[j]); P(l[j], A, d, null, g, m, w, v, _) } y > k ? ot(l, g, m, !0, !1, S) : Oe(f, d, b, g, m, w, v, _, S) }, Tt = (l, f, d, b, g, m, w, v, _) => { let y = 0; const k = f.length; let S = l.length - 1, j = k - 1; for (; y <= S && y <= j;) { const A = l[y], I = f[y] = _ ? Me(f[y]) : xe(f[y]); if (ut(A, I)) P(A, I, d, null, g, m, w, v, _); else break; y++ } for (; y <= S && y <= j;) { const A = l[S], I = f[j] = _ ? Me(f[j]) : xe(f[j]); if (ut(A, I)) P(A, I, d, null, g, m, w, v, _); else break; S--, j-- } if (y > S) { if (y <= j) { const A = j + 1, I = A < k ? f[A].el : b; for (; y <= j;)P(null, f[y] = _ ? Me(f[y]) : xe(f[y]), d, I, g, m, w, v, _), y++ } } else if (y > j) for (; y <= S;)be(l[y], g, m, !0), y++; else { const A = y, I = y, L = new Map; for (y = I; y <= j; y++) { const le = f[y] = _ ? Me(f[y]) : xe(f[y]); le.key != null && L.set(le.key, y) } let z, re = 0; const J = j - I + 1; let he = !1, oe = 0; const ct = new Array(J); for (y = 0; y < J; y++)ct[y] = 0; for (y = A; y <= S; y++) { const le = l[y]; if (re >= J) { be(le, g, m, !0); continue } let ye; if (le.key != null) ye = L.get(le.key); else for (z = I; z <= j; z++)if (ct[z - I] === 0 && ut(le, f[z])) { ye = z; break } ye === void 0 ? be(le, g, m, !0) : (ct[ye - I] = y + 1, ye >= oe ? oe = ye : he = !0, P(le, f[ye], d, null, g, m, w, v, _), re++) } const nn = he ? bo(ct) : Qe; for (z = nn.length - 1, y = J - 1; y >= 0; y--) { const le = I + y, ye = f[le], rn = le + 1 < k ? f[le + 1].el : b; ct[y] === 0 ? P(null, ye, d, rn, g, m, w, v, _) : he && (z < 0 || y !== nn[z] ? Le(ye, d, rn, 2) : z--) } } }, Le = (l, f, d, b, g = null) => { const { el: m, type: w, transition: v, children: _, shapeFlag: y } = l; if (y & 6) { Le(l.component.subTree, f, d, b); return } if (y & 128) { l.suspense.move(f, d, b); return } if (y & 64) { w.move(l, f, d, lt); return } if (w === ae) { n(m, f, d); for (let S = 0; S < _.length; S++)Le(_[S], f, d, b); n(l.anchor, f, d); return } if (w === gs) { V(l, f, d); return } if (b !== 2 && y & 1 && v) if (b === 0) v.beforeEnter(m), n(m, f, d), ce(() => v.enter(m), g); else { const { leave: S, delayLeave: j, afterLeave: A } = v, I = () => n(m, f, d), L = () => { S(m, () => { I(), A && A() }) }; j ? j(m, I, L) : L() } else n(m, f, d) }, be = (l, f, d, b = !1, g = !1) => { const { type: m, props: w, ref: v, children: _, dynamicChildren: y, shapeFlag: k, patchFlag: S, dirs: j, cacheIndex: A } = l; if (S === -2 && (g = !1), v != null && Ss(v, null, d, l, !0), A != null && (f.renderCache[A] = void 0), k & 256) { f.ctx.deactivate(l); return } const I = k & 1 && j, L = !pt(l); let z; if (L && (z = w && w.onVnodeBeforeUnmount) && _e(z, f, l), k & 6) Li(l.component, d, b); else { if (k & 128) { l.suspense.unmount(d, b); return } I && Ue(l, null, f, "beforeUnmount"), k & 64 ? l.type.remove(l, f, d, lt, b) : y && !y.hasOnce && (m !== ae || S > 0 && S & 64) ? ot(y, f, d, !1, !0) : (m === ae && S & 384 || !g && k & 16) && ot(_, f, d), b && Xs(l) } (L && (z = w && w.onVnodeUnmounted) || I) && ce(() => { z && _e(z, f, l), I && Ue(l, null, f, "unmounted") }, d) }, Xs = l => { const { type: f, el: d, anchor: b, transition: g } = l; if (f === ae) { $i(d, b); return } if (f === gs) { C(l); return } const m = () => { i(d), g && !g.persisted && g.afterLeave && g.afterLeave() }; if (l.shapeFlag & 1 && g && !g.persisted) { const { leave: w, delayLeave: v } = g, _ = () => w(d, m); v ? v(l.el, m, _) : _() } else m() }, $i = (l, f) => { let d; for (; l !== f;)d = x(l), i(l), l = d; i(f) }, Li = (l, f, d) => { const { bum: b, scope: g, job: m, subTree: w, um: v, m: _, a: y } = l; _n(_), _n(y), b && rs(b), g.stop(), m && (m.flags |= 8, be(w, l, f, d)), v && ce(v, f), ce(() => { l.isUnmounted = !0 }, f), f && f.pendingBranch && !f.isUnmounted && l.asyncDep && !l.asyncResolved && l.suspenseId === f.pendingId && (f.deps--, f.deps === 0 && f.resolve()) }, ot = (l, f, d, b = !1, g = !1, m = 0) => { for (let w = m; w < l.length; w++)be(l[w], f, d, b, g) }, Et = l => { if (l.shapeFlag & 6) return Et(l.component.subTree); if (l.shapeFlag & 128) return l.suspense.next(); const f = x(l.anchor || l.el), d = f && f[Dr]; return d ? x(d) : f }; let ns = !1; const en = (l, f, d) => { l == null ? f._vnode && be(f._vnode, null, null, !0) : P(f._vnode || null, l, f, null, null, null, d), f._vnode = l, ns || (ns = !0, hn(), ui(), ns = !1) }, lt = { p: P, um: be, m: Le, r: Xs, mt: ss, mc: Oe, pc: $, pbc: Ne, n: Et, o: e }; let tn, sn; return { render: en, hydrate: tn, createApp: ro(en, tn) } } function ds({ type: e, props: t }, s) { return s === "svg" && e === "foreignObject" || s === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : s } function Be({ effect: e, job: t }, s) { s ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function mo(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Ei(e, t, s = !1) { const n = e.children, i = t.children; if (T(n) && T(i)) for (let r = 0; r < n.length; r++) { const o = n[r]; let c = i[r]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = i[r] = Me(i[r]), c.el = o.el), !s && c.patchFlag !== -2 && Ei(o, c)), c.type === es && (c.el = o.el) } } function bo(e) { const t = e.slice(), s = [0]; let n, i, r, o, c; const u = e.length; for (n = 0; n < u; n++) { const h = e[n]; if (h !== 0) { if (i = s[s.length - 1], e[i] < h) { t[n] = i, s.push(n); continue } for (r = 0, o = s.length - 1; r < o;)c = r + o >> 1, e[s[c]] < h ? r = c + 1 : o = c; h < e[s[r]] && (r > 0 && (t[n] = s[r - 1]), s[r] = n) } } for (r = s.length, o = s[r - 1]; r-- > 0;)s[r] = o, o = t[o]; return s } function Oi(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Oi(t) } function _n(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const yo = Symbol.for("v-scx"), _o = () => Dt(yo); function hs(e, t, s) { return Ii(e, t, s) } function Ii(e, t, s = U) { const { immediate: n, deep: i, flush: r, once: o } = s, c = Q({}, s); let u; if (ts) if (r === "sync") { const x = _o(); u = x.__watcherHandles || (x.__watcherHandles = []) } else if (!t || n) c.once = !0; else return { stop: Se, resume: Se, pause: Se }; const h = ie; c.call = (x, E, M) => je(x, h, E, M); let a = !1; r === "post" ? c.scheduler = x => { ce(x, h && h.suspense) } : r !== "sync" && (a = !0, c.scheduler = (x, E) => { E ? x() : Vs(x) }), c.augmentJob = x => { t && (x.flags |= 4), a && (x.flags |= 2, h && (x.id = h.uid, x.i = h)) }; const p = Ir(e, t, c); return u && u.push(p), p } function vo(e, t, s) { const n = this.proxy, i = G(e) ? e.includes(".") ? Pi(n, e) : () => n[e] : e.bind(n, n); let r; O(t) ? r = t : (r = t.handler, s = t); const o = jt(this), c = Ii(i, r.bind(n), s); return o(), c } function Pi(e, t) { const s = t.split("."); return () => { let n = e; for (let i = 0; i < s.length && n; i++)n = n[s[i]]; return n } } const xo = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Ge(t)}Modifiers`] || e[`${Je(t)}Modifiers`]; function wo(e, t, ...s) { if (e.isUnmounted) return; const n = e.vnode.props || U; let i = s; const r = t.startsWith("update:"), o = r && xo(n, t.slice(7)); o && (o.trim && (i = s.map(a => G(a) ? a.trim() : a)), o.number && (i = s.map(Gi))); let c, u = n[c = is(t)] || n[c = is(Ge(t))]; !u && r && (u = n[c = is(Je(t))]), u && je(u, e, 6, i); const h = n[c + "Once"]; if (h) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, je(h, e, 6, i) } } function Mi(e, t, s = !1) { const n = t.emitsCache, i = n.get(e); if (i !== void 0) return i; const r = e.emits; let o = {}, c = !1; if (!O(e)) { const u = h => { const a = Mi(h, t, !0); a && (c = !0, Q(o, a)) }; !s && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } return !r && !c ? (W(e) && n.set(e, null), null) : (T(r) ? r.forEach(u => o[u] = null) : Q(o, r), W(e) && n.set(e, o), o) } function Xt(e, t) { return !e || !Kt(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), R(e, t[0].toLowerCase() + t.slice(1)) || R(e, Je(t)) || R(e, t)) } function ps(e) { const { type: t, vnode: s, proxy: n, withProxy: i, propsOptions: [r], slots: o, attrs: c, emit: u, render: h, renderCache: a, props: p, data: x, setupState: E, ctx: M, inheritAttrs: P } = e, ee = Lt(e); let D, K; try { if (s.shapeFlag & 4) { const C = i || n, q = C; D = xe(h.call(q, C, a, p, E, x, M)), K = c } else { const C = t; D = xe(C.length > 1 ? C(p, { attrs: c, slots: o, emit: u }) : C(p, null)), K = t.props ? c : So(c) } } catch (C) { mt.length = 0, Zt(C, e, 1), D = ge(xt) } let V = D; if (K && P !== !1) { const C = Object.keys(K), { shapeFlag: q } = V; C.length && q & 7 && (r && C.some(Is) && (K = jo(K, r)), V = it(V, K, !1, !0)) } return s.dirs && (V = it(V, null, !1, !0), V.dirs = V.dirs ? V.dirs.concat(s.dirs) : s.dirs), s.transition && Gs(V, s.transition), D = V, Lt(ee), D } const So = e => { let t; for (const s in e) (s === "class" || s === "style" || Kt(s)) && ((t || (t = {}))[s] = e[s]); return t }, jo = (e, t) => { const s = {}; for (const n in e) (!Is(n) || !(n.slice(9) in t)) && (s[n] = e[n]); return s }; function ko(e, t, s) { const { props: n, children: i, component: r } = e, { props: o, children: c, patchFlag: u } = t, h = r.emitsOptions; if (t.dirs || t.transition) return !0; if (s && u >= 0) { if (u & 1024) return !0; if (u & 16) return n ? vn(n, o, h) : !!o; if (u & 8) { const a = t.dynamicProps; for (let p = 0; p < a.length; p++) { const x = a[p]; if (o[x] !== n[x] && !Xt(h, x)) return !0 } } } else return (i || c) && (!c || !c.$stable) ? !0 : n === o ? !1 : n ? o ? vn(n, o, h) : !0 : !!o; return !1 } function vn(e, t, s) { const n = Object.keys(t); if (n.length !== Object.keys(e).length) return !0; for (let i = 0; i < n.length; i++) { const r = n[i]; if (t[r] !== e[r] && !Xt(s, r)) return !0 } return !1 } function Co({ vnode: e, parent: t }, s) { for (; t;) { const n = t.subTree; if (n.suspense && n.suspense.activeBranch === e && (n.el = e.el), n === e) (e = t.vnode).el = s, t = t.parent; else break } } const Ri = e => e.__isSuspense; function Ao(e, t) { t && t.pendingBranch ? T(e) ? t.effects.push(...e) : t.effects.push(e) : Fr(e) } const ae = Symbol.for("v-fgt"), es = Symbol.for("v-txt"), xt = Symbol.for("v-cmt"), gs = Symbol.for("v-stc"), mt = []; let ue = null; function Ve(e = !1) { mt.push(ue = e ? null : []) } function To() { mt.pop(), ue = mt[mt.length - 1] || null } let wt = 1; function xn(e) { wt += e, e < 0 && ue && (ue.hasOnce = !0) } function Fi(e) { return e.dynamicChildren = wt > 0 ? ue || Qe : null, To(), wt > 0 && ue && ue.push(e), e } function nt(e, t, s, n, i, r) { return Fi(N(e, t, s, n, i, r, !0)) } function Eo(e, t, s, n, i) { return Fi(ge(e, t, s, n, i, !0)) } function Oo(e) { return e ? e.__v_isVNode === !0 : !1 } function ut(e, t) { return e.type === t.type && e.key === t.key } const zi = ({ key: e }) => e ?? null, Ht = ({ ref: e, ref_key: t, ref_for: s }) => (typeof e == "number" && (e = "" + e), e != null ? G(e) || Z(e) || O(e) ? { i: we, r: e, k: t, f: !!s } : e : null); function N(e, t = null, s = null, n = 0, i = null, r = e === ae ? 0 : 1, o = !1, c = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && zi(t), ref: t && Ht(t), scopeId: di, slotScopeIds: null, children: s, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: r, patchFlag: n, dynamicProps: i, dynamicChildren: null, appContext: null, ctx: we }; return c ? (Ys(u, s), r & 128 && e.normalize(u)) : s && (u.shapeFlag |= G(s) ? 8 : 16), wt > 0 && !o && ue && (u.patchFlag > 0 || r & 6) && u.patchFlag !== 32 && ue.push(u), u } const ge = Io; function Io(e, t = null, s = null, n = 0, i = null, r = !1) { if ((!e || e === Zr) && (e = xt), Oo(e)) { const c = it(e, t, !0); return s && Ys(c, s), wt > 0 && !r && ue && (c.shapeFlag & 6 ? ue[ue.indexOf(e)] = c : ue.push(c)), c.patchFlag = -2, c } if (Lo(e) && (e = e.__vccOpts), t) { t = Po(t); let { class: c, style: u } = t; c && !G(c) && (t.class = qt(c)), W(u) && (Bs(u) && !T(u) && (u = Q({}, u)), t.style = Rs(u)) } const o = G(e) ? 1 : Ri(e) ? 128 : Hr(e) ? 64 : W(e) ? 4 : O(e) ? 2 : 0; return N(e, t, s, n, i, o, r, !0) } function Po(e) { return e ? Bs(e) || wi(e) ? Q({}, e) : e : null } function it(e, t, s = !1, n = !1) { const { props: i, ref: r, patchFlag: o, children: c, transition: u } = e, h = t ? Mo(i || {}, t) : i, a = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: h, key: h && zi(h), ref: t && t.ref ? s && r ? T(r) ? r.concat(Ht(t)) : [r, Ht(t)] : Ht(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: c, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ae ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: u, component: e.component, suspense: e.suspense, ssContent: e.ssContent && it(e.ssContent), ssFallback: e.ssFallback && it(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return u && n && Gs(a, u.clone(a)), a } function Bt(e = " ", t = 0) { return ge(es, null, e, t) } function xe(e) { return e == null || typeof e == "boolean" ? ge(xt) : T(e) ? ge(ae, null, e.slice()) : typeof e == "object" ? Me(e) : ge(es, null, String(e)) } function Me(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : it(e) } function Ys(e, t) { let s = 0; const { shapeFlag: n } = e; if (t == null) t = null; else if (T(t)) s = 16; else if (typeof t == "object") if (n & 65) { const i = t.default; i && (i._c && (i._d = !1), Ys(e, i()), i._c && (i._d = !0)); return } else { s = 32; const i = t._; !i && !wi(t) ? t._ctx = we : i === 3 && we && (we.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else O(t) ? (t = { default: t, _ctx: we }, s = 32) : (t = String(t), n & 64 ? (s = 16, t = [Bt(t)]) : s = 8); e.children = t, e.shapeFlag |= s } function Mo(...e) { const t = {}; for (let s = 0; s < e.length; s++) { const n = e[s]; for (const i in n) if (i === "class") t.class !== n.class && (t.class = qt([t.class, n.class])); else if (i === "style") t.style = Rs([t.style, n.style]); else if (Kt(i)) { const r = t[i], o = n[i]; o && r !== o && !(T(r) && r.includes(o)) && (t[i] = r ? [].concat(r, o) : o) } else i !== "" && (t[i] = n[i]) } return t } function _e(e, t, s, n = null) { je(e, t, 7, [s, n]) } const Ro = _i(); let Fo = 0; function zo(e, t, s) { const n = e.type, i = (t ? t.appContext : e.appContext) || Ro, r = { uid: Fo++, vnode: e, type: n, parent: t, appContext: i, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new er(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(i.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: ji(n, i), emitsOptions: Mi(n, i), emit: null, emitted: null, propsDefaults: U, inheritAttrs: n.inheritAttrs, ctx: U, data: U, props: U, attrs: U, slots: U, refs: U, setupState: U, setupContext: null, suspense: s, suspenseId: s ? s.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = wo.bind(null, r), e.ce && e.ce(r), r } let ie = null, Wt, Ts; { const e = Un(), t = (s, n) => { let i; return (i = e[s]) || (i = e[s] = []), i.push(n), r => { i.length > 1 ? i.forEach(o => o(r)) : i[0](r) } }; Wt = t("__VUE_INSTANCE_SETTERS__", s => ie = s), Ts = t("__VUE_SSR_SETTERS__", s => ts = s) } const jt = e => { const t = ie; return Wt(e), e.scope.on(), () => { e.scope.off(), Wt(t) } }, wn = () => { ie && ie.scope.off(), Wt(null) }; function Di(e) { return e.vnode.shapeFlag & 4 } let ts = !1; function Do(e, t = !1, s = !1) { t && Ts(t); const { props: n, children: i } = e.vnode, r = Di(e); lo(e, n, r, t), ao(e, i, s); const o = r ? Ho(e, t) : void 0; return t && Ts(!1), o } function Ho(e, t) { const s = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Qr); const { setup: n } = s; if (n) { const i = e.setupContext = n.length > 1 ? $o(e) : null, r = jt(e); De(); const o = St(n, e, 0, [e.props, i]); if (He(), r(), Dn(o)) { if (pt(e) || hi(e), o.then(wn, wn), t) return o.then(c => { Sn(e, c, t) }).catch(c => { Zt(c, e, 0) }); e.asyncDep = o } else Sn(e, o, t) } else Hi(e, t) } function Sn(e, t, s) { O(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : W(t) && (e.setupState = li(t)), Hi(e, s) } let jn; function Hi(e, t, s) { const n = e.type; if (!e.render) { if (!t && jn && !n.render) { const i = n.template || qs(e).template; if (i) { const { isCustomElement: r, compilerOptions: o } = e.appContext.config, { delimiters: c, compilerOptions: u } = n, h = Q(Q({ isCustomElement: r, delimiters: c }, o), u); n.render = jn(i, h) } } e.render = n.render || Se } { const i = jt(e); De(); try { Xr(e) } finally { He(), i() } } } const No = { get(e, t) { return X(e, "get", ""), e[t] } }; function $o(e) { const t = s => { e.exposed = s || {} }; return { attrs: new Proxy(e.attrs, No), slots: e.slots, emit: e.emit, expose: t } } function Zs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(li(jr(e.exposed)), { get(t, s) { if (s in t) return t[s]; if (s in gt) return gt[s](e) }, has(t, s) { return s in t || s in gt } })) : e.proxy } function Lo(e) { return O(e) && "__vccOpts" in e } const Uo = (e, t) => Er(e, t, ts), Bo = "3.5.5";/**
* @vue/runtime-dom v3.5.5
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Es; const kn = typeof window < "u" && window.trustedTypes; if (kn) try { Es = kn.createPolicy("vue", { createHTML: e => e }) } catch { } const Ni = Es ? e => Es.createHTML(e) : e => e, Wo = "http://www.w3.org/2000/svg", Ko = "http://www.w3.org/1998/Math/MathML", Ce = typeof document < "u" ? document : null, Cn = Ce && Ce.createElement("template"), Vo = { insert: (e, t, s) => { t.insertBefore(e, s || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, s, n) => { const i = t === "svg" ? Ce.createElementNS(Wo, e) : t === "mathml" ? Ce.createElementNS(Ko, e) : s ? Ce.createElement(e, { is: s }) : Ce.createElement(e); return e === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i }, createText: e => Ce.createTextNode(e), createComment: e => Ce.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Ce.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, s, n, i, r) { const o = s ? s.previousSibling : t.lastChild; if (i && (i === r || i.nextSibling)) for (; t.insertBefore(i.cloneNode(!0), s), !(i === r || !(i = i.nextSibling));); else { Cn.innerHTML = Ni(n === "svg" ? `<svg>${e}</svg>` : n === "mathml" ? `<math>${e}</math>` : e); const c = Cn.content; if (n === "svg" || n === "mathml") { const u = c.firstChild; for (; u.firstChild;)c.appendChild(u.firstChild); c.removeChild(u) } t.insertBefore(c, s) } return [o ? o.nextSibling : t.firstChild, s ? s.previousSibling : t.lastChild] } }, Go = Symbol("_vtc"); function qo(e, t, s) { const n = e[Go]; n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : s ? e.setAttribute("class", t) : e.className = t } const An = Symbol("_vod"), Jo = Symbol("_vsh"), Yo = Symbol(""), Zo = /(^|;)\s*display\s*:/; function Qo(e, t, s) { const n = e.style, i = G(s); let r = !1; if (s && !i) { if (t) if (G(t)) for (const o of t.split(";")) { const c = o.slice(0, o.indexOf(":")).trim(); s[c] == null && Nt(n, c, "") } else for (const o in t) s[o] == null && Nt(n, o, ""); for (const o in s) o === "display" && (r = !0), Nt(n, o, s[o]) } else if (i) { if (t !== s) { const o = n[Yo]; o && (s += ";" + o), n.cssText = s, r = Zo.test(s) } } else t && e.removeAttribute("style"); An in e && (e[An] = r ? n.display : "", e[Jo] && (n.display = "none")) } const Tn = /\s*!important$/; function Nt(e, t, s) { if (T(s)) s.forEach(n => Nt(e, t, n)); else if (s == null && (s = ""), t.startsWith("--")) e.setProperty(t, s); else { const n = Xo(e, t); Tn.test(s) ? e.setProperty(Je(n), s.replace(Tn, ""), "important") : e[n] = s } } const En = ["Webkit", "Moz", "ms"], ms = {}; function Xo(e, t) { const s = ms[t]; if (s) return s; let n = Ge(t); if (n !== "filter" && n in e) return ms[t] = n; n = $n(n); for (let i = 0; i < En.length; i++) { const r = En[i] + n; if (r in e) return ms[t] = r } return t } const On = "http://www.w3.org/1999/xlink"; function In(e, t, s, n, i, r = Xi(t)) { n && t.startsWith("xlink:") ? s == null ? e.removeAttributeNS(On, t.slice(6, t.length)) : e.setAttributeNS(On, t, s) : s == null || r && !Bn(s) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : ze(s) ? String(s) : s) } function el(e, t, s, n) { if (t === "innerHTML" || t === "textContent") { s != null && (e[t] = t === "innerHTML" ? Ni(s) : s); return } const i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { const o = i === "OPTION" ? e.getAttribute("value") || "" : e.value, c = s == null ? e.type === "checkbox" ? "on" : "" : String(s); (o !== c || !("_value" in e)) && (e.value = c), s == null && e.removeAttribute(t), e._value = s; return } let r = !1; if (s === "" || s == null) { const o = typeof e[t]; o === "boolean" ? s = Bn(s) : s == null && o === "string" ? (s = "", r = !0) : o === "number" && (s = 0, r = !0) } try { e[t] = s } catch { } r && e.removeAttribute(t) } function tl(e, t, s, n) { e.addEventListener(t, s, n) } function sl(e, t, s, n) { e.removeEventListener(t, s, n) } const Pn = Symbol("_vei"); function nl(e, t, s, n, i = null) { const r = e[Pn] || (e[Pn] = {}), o = r[t]; if (n && o) o.value = n; else { const [c, u] = il(t); if (n) { const h = r[t] = ll(n, i); tl(e, c, h, u) } else o && (sl(e, c, o, u), r[t] = void 0) } } const Mn = /(?:Once|Passive|Capture)$/; function il(e) { let t; if (Mn.test(e)) { t = {}; let n; for (; n = e.match(Mn);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Je(e.slice(2)), t] } let bs = 0; const rl = Promise.resolve(), ol = () => bs || (rl.then(() => bs = 0), bs = Date.now()); function ll(e, t) { const s = n => { if (!n._vts) n._vts = Date.now(); else if (n._vts <= s.attached) return; je(cl(n, s.value), t, 5, [n]) }; return s.value = e, s.attached = ol(), s } function cl(e, t) { if (T(t)) { const s = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { s.call(e), e._stopped = !0 }, t.map(n => i => !i._stopped && n && n(i)) } else return t } const Rn = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, fl = (e, t, s, n, i, r) => { const o = i === "svg"; t === "class" ? qo(e, n, o) : t === "style" ? Qo(e, s, n) : Kt(t) ? Is(t) || nl(e, t, s, n, r) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : ul(e, t, n, o)) ? (el(e, t, n), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && In(e, t, n, o, r, t !== "value")) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), In(e, t, n, o)) }; function ul(e, t, s, n) { if (n) return !!(t === "innerHTML" || t === "textContent" || t in e && Rn(t) && O(s)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const i = e.tagName; if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE") return !1 } return Rn(t) && G(s) ? !1 : !!(t in e || e._isVueCE && (/[A-Z]/.test(t) || !G(s))) } const al = Q({ patchProp: fl }, Vo); let Fn; function dl() { return Fn || (Fn = po(al)) } const hl = (...e) => { const t = dl().createApp(...e), { mount: s } = t; return t.mount = n => { const i = gl(n); if (!i) return; const r = t._component; !O(r) && !r.render && !r.template && (r.template = i.innerHTML), i.nodeType === 1 && (i.textContent = ""); const o = s(i, !1, pl(i)); return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o }, t }; function pl(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function gl(e) { return G(e) ? document.querySelector(e) : e } const ml = ["href"], bl = ["href", "aria-label"], yl = ["src", "alt"], _l = { __name: "project", props: { name: String, link: String, image: String, description: String, skills: String, categories: String }, setup(e) { return (t, s) => (Ve(), nt(ae, null, [N("link", { rel: "preload", fetchpriority: "high", as: "image", href: e.image === "" ? "https://placeholder.co/600x400/?text=NoImage" : e.image, type: "image/png" }, null, 8, ml), N("div", { class: qt(["item "].concat(e.categories.split(" "))) }, [N("a", { href: e.link, "aria-label": "See the site for " + e.name }, [N("img", { src: e.image === "" ? "https://placeholder.co/600x400/?text=NoImage" : e.image, alt: "Project photo for" + e.name }, null, 8, yl), N("h4", null, zt(e.name), 1)], 8, bl), N("p", null, zt(e.description), 1), N("p", null, [s[1] || (s[1] = Bt("skills learned:")), (Ve(!0), nt(ae, null, bi(e.skills.split(","), (n, i) => (Ve(), nt("span", { key: i }, [N("em", null, [s[0] || (s[0] = N("br", null, null, -1)), Bt(zt(n), 1)])]))), 128))])], 2)], 64)) } }, vl = ["href"], xl = ["src"], ys = { __name: "imagelink", props: { link: String, image: String }, setup(e) { return (t, s) => (Ve(), nt("a", { href: e.link, style: { "text-decoration": "none", display: "block" } }, [N("img", { src: e.image, alt: "linkedin", style: { width: "32px" } }, null, 8, xl), s[0] || (s[0] = Bt("  "))], 8, vl)) } }, wl = (e, t) => { const s = e.__vccOpts || e; for (const [n, i] of t) s[n] = i; return s }, Sl = { style: { display: "flex", "justify-content": "center" } }, jl = { id: "hobbys" }, kl = { style: { width: "100%", display: "flex", "justify-content": "center" } }, Cl = { id: "projects" }, Al = {
            __name: "App", setup(e) {
                const t = us([{ name: "Airport Game", skills: "JSON,leaderboard", categories: "c a fav", link: "https://jdszekeres.github.io/airport.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/airport-game.png", description: "Try to guess all the airports in the US (There's over 350)" }, { name: "Chess.com Stats", skills: "API,graphs", categories: "c", link: "https://jdszekeres.github.io/chesscom.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/chesscom-stats.png", description: "Uses chess.com open database to look at your chess skills statistically" }, { name: "Pixel Art Color by Number", skills: "JSON,user settings,UI design", categories: "c fav", link: "https://jdszekeres.github.io/pixelart.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/pixel-color-by-number.png", description: "A color by number game on a 32x32 grid" }, { name: "Reigonle", skills: "maps,wordle style random generation", categories: "c g fav", link: "https://jdszekeres.github.io/reigonle.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/reigonle.png", description: "A wordle type game where you guess a country every day to fill in your map" }, { name: "War ", skills: "API", categories: "c", link: "https://jdszekeres.github.io/war.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/war-cards.png", description: "To prove war is all luck, play this bot." }, { name: "Word Guess", skills: "wordle style random generation,API", categories: "c", link: "https://jdszekeres.github.io/wordguess.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/word-guess.png", description: "A wordle type game where you guess a word by searching for synomyns and rythming words" }, { name: "Machine Learning Class", skills: "machine learning", categories: "c", link: "https://jdszekeres.github.io/ml.html", image: "", description: "ML program for a class I took" }, { name: "Chrome Startup Screen", skills: "perlin noise, reverse engineering", categories: "c fav", link: "https://jdszekeres.github.io/chrome.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/browser-start-screen.png", description: "A start screen that includes all the strange holidays and a procedural heightmap gradient" }, { name: "Projectile Motion Calc", skills: "trig", categories: "c", link: "https://jdszekeres.github.io/projectile%20motion.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/projectile-motion.png", description: "A calculator that calculates projectile motion based on Firing Angle and Exit Speed" }, { name: "Wage counter", skills: "setInterval,setTimeout", categories: "c", link: "https://jdszekeres.github.io/wage.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/income-clock.png", description: "A timer that calculates how much you earn" }, { name: "Space Invader", skills: "pygame", categories: "c", link: "https://github.com/jdszekeres/space-invader", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/space-invader.png", description: "Space invaders in python (Multiple Levels)" }, { name: "EZL", skills: "lexing", categories: "c", link: "https://github.com/jdszekeres/ezl", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/ezl.png", description: "A mini programming language interperted in python" }, { name: "FlaskEnv", skills: "bash download", categories: "c", link: "https://github.com/jdszekeres/flaskenv", image: "", description: "Easily create a mini flask enviroment" }, { name: "Window Seat Simulator", skills: "maps,API,Mapbox", categories: "c a fav", link: "https://github.com/jdszekeres/windowseat", image: "https://jdszekeres.github.io/project-photos/windowseat.jpg", description: "A program that uses angled satelite imagery to simulate the view outside of a plane" }, { name: "Choose Your Own Adventure", skills: "recursion,story telling", categories: "c", link: "https://replit.com/@wong-csf-f23-p1/U109c-Python-Adventure-Project-jdszekeres?embed=true", image: "https://t3.ftcdn.net/jpg/06/22/07/90/360_F_622079039_2mFtFQpSv7Z9hdcDdWHj1eTNZIwQP5Z0.jpg", description: "A chose your own adventure for my CS class. Ms. Wong why didn't you tell me we didn't we didn't need 4 endings?" }, { name: "City Builder", skills: "sqlite,pixel art", categories: "c g", link: "https://github.com/jdszekeres/city-builder", image: "https://jdszekeres.github.io/project-photos/city-builder.png", description: "A clone of Sim City build it in the browser with subpar graphics" }, { name: "City Builder 2: electric boogaloo", skills: "JSON,pixel art,UI design", categories: "c g", link: "https://github.com/jdszekeres/citybuilder2.0", image: "https://jdszekeres.github.io/project-photos/citybuilder2.png", description: "A more complex better looking (At least that's what I tell myself) version on citybuilder1.0" }, { name: "Gimkit Pratice Test", skills: "reverse engineering,bootstrap", categories: "c", link: "https://jdszekeres.github.io/gimkittest.html", image: "https://jdszekeres.github.io/project-photos/gimkit.png", description: "A reskinned version of Gimkit practice questions" }, { name: "Spotify Game", skills: "API,oauth", categories: "c fav", link: "https://jdszekeres.github.io/spotify.html", image: "https://jdszekeres.github.io/project-photos/spotify.png", description: "A spotify game that uses the spotify API to get your playlists and quiz you on how well you know your playlists" }, { name: "Trivia", skills: "API", categories: "c", link: "https://jdszekeres.github.io/trivia.html", image: "https://jdszekeres.github.io/project-photos/trivia.png", description: "A trivia game that uses the trivia api" }, { name: "dispenser", skills: "CAD", categories: "3", link: "https://www.thingiverse.com/thing:6286816", image: "", description: "A dispenser for solid objects" }, { name: "All Things Dashboard", skills: "API,reverse enginnering,UI design,user settings", categories: "c fav", link: "https://allthingsdashboard.vercel.app/settings", image: "https://jdszekeres.github.io/project-photos/allthingsdashboard.png", description: "A central dashboard to integrate your favorite data sources into one view" }, { name: "IOCCC Hacker Type Feed", skills: "scraping", categories: "c", link: "https://replit.com/@jdszekeres/IOCCC-Hacker-Type?", image: "https://jdszekeres.github.io/project-photos/hackerType.png", description: "Generates a file you can upload to hackertype.net to use ioccc data (It looks much better)" }, { name: "Aeries Parser", skills: "reverse engineering,API", categories: "c", link: "https://jdszekeres.github.io/aeriesparser.html", image: "https://jdszekeres.github.io/project-photos/aeriesparser.png", description: "A parser for the popular SIS program Aeries that gets a static version of the site and allows it to do thing like calculate final grades." }, { name: "Ticking Timer", skills: "audio", categories: "c", link: "https://jdszekeres.github.io/tickingtimer.html", image: "", description: "A timer that counts down to a set time with a ticking sound. Made for my English teacher." }, { name: "Trail Markers", skills: "UI Design, Figma, file upload", categories: "c g", link: "https://jdszekeres.github.io/strava.html", image: "https://raw.githubusercontent.com/jdszekeres/trailMarkers/main/screenshot.png", description: "A website that allows you to upload a running route and calculates how much time it takes you to run an individual section" }, { name: "Kppen Flights", skills: "Turfjs, tailwind, geoJSON, UI Design", categories: "c g a", link: "https://jdszekeres.github.io/koppenFlight.html", image: "https://raw.githubusercontent.com/jdszekeres/jdszekeres.github.io/main/project-photos/koppenFlight.png", description: "A website that allow you to examine the distribution of Kppen-Geiger climate zones across a flight path" }, { name: "Virtual Real Estate", skills: "API, THREE.js, leaflet, UI Design", categories: "c g fav", link: "https://jdszekeres.github.io/virtualRealEstate/", image: "https://jdszekeres.github.io/project-photos/virtualRealEstate.png", description: "A site that allow you to model a house or building on a piece of virtual land based on satelite imagery" }, { name: "Correct Horse Battery Staple Password Generator", skills: "API, pure-css", categories: "c", link: "https://jdszekeres.github.io/passwordEntropy.html", image: "", description: "A password generator that allow you to drop in categories of words" }]); let s = us([]), n = us(t.value); function i(r) { const o = s.value.includes(r); s.value = [], !o && r !== "" && s.value.push(r), n.value = t.value.filter(c => s.value.length === 0 || c.categories.split(" ").some(u => u === r)) } return (r, o) => (Ve(), nt("main", null, [o[7] || (o[7] = N("h1", null, "Hi, I'm jdszekeres", -1)), o[8] || (o[8] = N("h2", {
                    style: {
                        "font-size": "48px", "font-family": `system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI' , Roboto,
                Oxygen, Ubuntu, Cantarell, 'Open Sans' , 'Helvetica Neue' , sans-serif`}
                }, " an avid computer scientist and lover of knowledge", -1)), o[9] || (o[9] = N("h4", null, "You can look for me here:", -1)), N("div", Sl, [ge(ys, { link: "www.linkedin.com/in/jdszekeres", image: "LI-logo.png" }), ge(ys, { link: "https://github.com/jdszekeres", image: "github-mark.svg" }), ge(ys, { link: "https://github.com/CCA-AppDev", image: "cca-appdev.png" })]), o[10] || (o[10] = N("h3", { style: { "font-size": "36px" } }, "my hobbies include", -1)), N("div", jl, [N("button", { class: "hobby", id: "cs", onClick: o[0] || (o[0] = c => i("c")), style: { "min-width": "250px !important" } }, o[5] || (o[5] = [N("div", { id: "hack" }, "Computer Science", -1)])), N("button", { class: "hobby", onClick: o[1] || (o[1] = c => i("a")), style: { width: "150px" } }, o[6] || (o[6] = [N("div", { id: "aviation" }, "aviation", -1)])), N("button", { class: "hobby", onClick: o[2] || (o[2] = c => i("3")), id: "printing" }, "3D printing"), N("button", { class: "hobby", onClick: o[3] || (o[3] = c => i("g")), id: "geo" }, "Geography")]), N("div", kl, [N("button", { class: "hobby", onClick: o[4] || (o[4] = c => i("fav")) }, "My Favorite Projects")]), N("div", Cl, [(Ve(!0), nt(ae, null, bi(oi(n), (c, u) => (Ve(), Eo(_l, { key: u, skills: c.skills, categories: c.categories, name: c.name, link: c.link, image: c.image, description: c.description }, null, 8, ["skills", "categories", "name", "link", "image", "description"]))), 128))])]))
            }
        }, Tl = wl(Al, [["__scopeId", "data-v-6e5c6853"]]); hl(Tl).mount("#app");
    </script>
    <style rel="stylesheet" crossorigin>
        @import"https://fonts.googleapis.com/css2?family=Fira+Code&family=Roboto:wght@500&display=swap";
        @media screen and (orientation:portrait) {
            a {
                font-size: 15px;
                overflow: scroll
            }

            p {
                font-size: 12px
            }

            .item {
                width: calc(50% - 20px)
            }
        }

        .item {
            width: calc((100% / 3) - (5px * 3));
            height: 50%;
            padding: 5px
        }

        img {
            width: min(100%, 500px)
        }

        h4 {
            width: 100%;
            text-align: center;
            font-family: Fira Code, Roboto, sans-serif
        }

        a {
            font-size: 25px
        }

        p {
            width: 100%;
            color: #dcdcdc;
            font-size: 16px;
            font-weight: 700
        }

        @media (hover: hover) {
            a:hover {
                background-color: transparent
            }
        }

        @media screen and (orientation:portrait) {
            .hobbdy[data-v-6e5c6853] {
                width: 100%
            }
        }

        #projects[data-v-6e5c6853] {
            display: flex;
            flex-wrap: wrap
        }

        h1[data-v-6e5c6853] {
            font-weight: 800;
            font-size: 64px;
            font-family: roboto;
            width: 100%;
            text-align: center;
            color: radial-gradient(circle, rgba(41, 41, 39, 1) 0%, rgba(64, 59, 14, 1) 100%)
        }

        h2[data-v-6e5c6853],
        h3[data-v-6e5c6853] {
            text-align: center
        }

        #hobbys[data-v-6e5c6853] {
            margin: auto;
            text-align: center;
            width: 100%;
            overflow-wrap: wrap
        }

        .hobby[data-v-6e5c6853] {
            margin: 10px;
            padding: 10px;
            font-size: 22px;
            background: none;
            border: 3px solid black;
            height: 50.4px;
            position: relative
        }

        #cs[data-v-6e5c6853] {
            color: #78ff78;
            min-width: 200px
        }

        #hack[data-v-6e5c6853] {
            font-family: monospace;
            font-size: 20px;
            white-space: nowrap;
            text-shadow: 0 2px 2px rgba(#000, .9)
        }

        @keyframes landing-6e5c6853 {
            0% {
                transform: translate3d(-30%, -30%, 0)
            }

            to {
                transform: translate3d(30%, 35%, 0)
            }
        }

        #aviation[data-v-6e5c6853] {
            animation: landing-6e5c6853 2s ease-in-out infinite
        }

        #geo[data-v-6e5c6853] {
            background-image: url(geography.gif);
            background-size: cover
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #2f3454;
                background: radial-gradient(circle, #2f3454, #445278)
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                background: #6f7bc8;
                background: radial-gradient(circle, #6f7bc8, #607abe)
            }
        }

        a,
        .green {
            text-decoration: none;
            color: #00bd7e;
            transition: .4s
        }

        @media (hover: hover) {
            a:hover {
                background-color: #00bd7e33
            }
        }
    </style>
</head>

<body>
    <div id="app">

    </div>
</body>
<script>
    class Messenger {
        constructor(el) {
            this.el = el
            this.codeletters = "abcdefghijklmnopqrstuvwxyz1234567890-=ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            this.message = 0;
            this.currentLength = 0;
            this.fadeBuffer = false;
            this.messages = [
                'Computer Science',
                'Machine Learning',
                'Web Development',
                'IOS Development',
                'Cryptography'
            ];

            setTimeout(() => this.animateIn(), 100);
        }

        generateRandomString(length) {
            var randomText = "";
            while (randomText.length < length) {
                randomText += this.codeletters.charAt(Math.floor(Math.random() * this.codeletters.length));
            }

            return randomText;
        }

        animateIn() {
            if (this.currentLength < this.messages[this.message].length) {
                this.currentLength += 2;
                if (this.currentLength > this.messages[this.message].length) {
                    this.currentLength = this.messages[this.message].length;
                }

                var message = this.generateRandomString(this.currentLength);
                this.el.innerHTML = message;

                setTimeout(() => this.animateIn(), 20);
            } else {
                setTimeout(() => this.animateFadeBuffer(), 20);
            }
        }

        animateFadeBuffer() {
            if (!this.fadeBuffer) {
                this.fadeBuffer = [];
                for (let i = 0; i < this.messages[this.message].length; i++) {
                    this.fadeBuffer.push({
                        c: Math.floor(Math.random() * 12) + 1,
                        l: this.messages[this.message].charAt(i)
                    });
                }
            }

            let doCycles = false;
            let message = "";

            for (let i = 0; i < this.fadeBuffer.length; i++) {
                var fader = this.fadeBuffer[i];
                if (fader.c > 0) {
                    doCycles = true;
                    fader.c--;
                    message += this.codeletters.charAt(Math.floor(Math.random() * this.codeletters.length));
                } else {
                    message += fader.l;
                }
            }

            this.el.innerHTML = message;

            if (doCycles) {
                setTimeout(() => this.animateFadeBuffer(), 50);
            } else {
                setTimeout(() => this.cycleText(), 2000);
            }
        }

        cycleText() {
            this.message++;
            if (this.message >= this.messages.length) {
                this.message = 0;
            }

            this.currentLength = 0;
            this.fadeBuffer = false;
            this.el.innerHTML = "";

            setTimeout(() => this.animateIn(), 200);
        }

        init() {
            this.animateIn();
        }
    }


    setTimeout(() => new Messenger(document.getElementById('cs')), 1000)

    function updateBackground(element, progress) {
        style = element.style;
        style.background = `linear-gradient(0deg,rgb(0,0,0) 0%,rgb(0, 0, 0) ${progress}%,rgb(255,255,255) ${progress + 0.01}%, rgb(255, 255, 255) 100%)`;
        style.backgroundColor = "#000";
        style.backgroundSize = "100%";
        style.backgroundRepeat = "repeat";

        // Set the background to be clipped to the text and transparent
        style.webkitBackgroundClip = "text";
        style.webkitTextFillColor = "transparent";
        style.mozBackgroundClip = "text";
        style.mozTextFillColor = "transparent";

    }

    count = 0;
    setTimeout(() => {
        setInterval(() => {
            count++;
            count = count % 100;
            updateBackground(document.getElementById('printing'), count);
        }, 50)
    }, 1000)
</script>

</html>